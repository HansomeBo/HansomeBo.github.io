<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>HandsomeBo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="HandsomeBo">
<meta property="og:url" content="http://handsomebo.com/index.html">
<meta property="og:site_name" content="HandsomeBo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HandsomeBo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HandsomeBo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://handsomebo.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-个人简历-徐博" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/" class="article-date">
  <time class="dt-published" datetime="2022-06-01T12:10:33.000Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/">个人简历</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>| <img src="https://cdn.nlark.com/yuque/0/2022/png/1982501/1654254000946-da016aa9-2f2d-4442-838a-24e7afe679a9.png#clientId=ueb42f994-ba41-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=131&id=ub41e6ffc&margin=%5Bobject%20Object%5D&name=head3.png&originHeight=483&originWidth=387&originalType=binary&ratio=1&rotation=0&showTitle=false&size=323346&status=done&style=none&taskId=ucb1d64da-a023-433d-a437-21efe8aa9a7&title=&width=105" alt="head3.png"> | </p>
<ul>
<li>徐博｜男｜1994 </li>
<li>工作年限 5年｜Base 北京</li>
<li>手机 18844063961｜邮箱 <a href="mailto:&#x68;&#x61;&#x6e;&#x73;&#111;&#x6d;&#x65;&#98;&#111;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#x68;&#x61;&#x6e;&#x73;&#111;&#x6d;&#x65;&#98;&#111;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a>｜微信 hansomebo<br> |<br>| — | — |</li>
</ul>
<p><strong>技能清单</strong></p>
<ul>
<li>Java基础、微服务、缓存、消息队列、数据库</li>
<li>分布式事务、网关路由、熔断降级、负载均衡、Service Mesh</li>
<li>JVM调优、QPS调优、接口幂等、柔性事务</li>
</ul>
<hr>
<p><strong>工作经历</strong><br><strong>美团 ｜Java后端｜2021.02 ~ 2022.04</strong><br>技术：从0到1搭建新系统，技术选型与开发，技术说明文档与对接文档<br>业务：数据流量监控，组件、类信息聚集监控追踪，APP集成任务流程调度，APP迭代管控<br><strong>首金金融｜Java后端｜ 2017.08 ~ 2021.02</strong><br>技术： 单体服务 → 微服务转型，系统设计、技术方案选型和落地，公共服务搭建、代码Review<br>业务： 信贷资产交易系统、产品、费用、任务调度、对账等系统<br><strong>东方国信｜实习生｜2016.08 ~ 2017.06</strong></p>
<hr>
<p><strong>项目经历</strong><br><strong>APP中心｜系统设计&amp;开发｜美团</strong><br>技术：	SpringBoot、异步消息、分布式缓存、ElasticSearch全文检索<br>描述：	全平台APP数据监控，组件、类数据的聚合，统一化接口对接全平台系统<br>业绩：	推进平台数据统一，组件、类相关信息责任信息统一，方便监控追踪<br><strong>信贷交易系统｜开发组长&amp;系统设计｜首金</strong><br>技术：	SpringCloud、Eureka、Config、Hystrix、Ribbon、ZipKin、Monitor<br>        MySQL、TCC、Redis、RabbitMQ<br>描述：	分布式事务，自研开发TCC保证数据一致<br>        账户中心，优化热点账户，保证账户资金不错帐，提升海量明细查询速度<br>业绩：	资产端单体服务到微服务架构转型，提高交易并发处理能力，异常自治理能力，快速迭代更新能力<br><strong>其他项目</strong><br>分布式任务调度系统：定时任务灵活配置、任务分批、分步<br>交易对账系统：实时对账、离线T+1对账<br>文本分析系统：全文检索、文本数据结构化处理</p>
<hr>
<p><strong>教育经历</strong><br><strong>长春理工大学｜本科｜软件工程｜2013 ~ 2017</strong></p>
<ul>
<li>参加大学生创业比赛，大学生兼职项目，创业比赛三等奖</li>
<li>阿里云服务器部署，校内三千用户注册</li>
<li>英语社团和轮滑社团校区负责人</li>
</ul>
<hr>
<p><strong>荣誉奖项</strong><br>首金年度最佳员工<br>大学生创业比赛三等奖</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2022/06/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/" data-id="cl3zh4t310001ma7s92lhblmm" data-title="个人简历" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%80%E5%8E%86/" rel="tag">简历</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/系统设计相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/01/yuque/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2022-06-01T11:05:03.000Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/01/yuque/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/">系统设计相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-怎么设计一个大文件上传的功能？"><a href="#1-怎么设计一个大文件上传的功能？" class="headerlink" title="1.怎么设计一个大文件上传的功能？"></a><a href="#%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F">1.怎么设计一个大文件上传的功能？</a></h4><h4 id="2-谈一谈分布式-ID-生成方案的了解？"><a href="#2-谈一谈分布式-ID-生成方案的了解？" class="headerlink" title="2.谈一谈分布式 ID 生成方案的了解？"></a><a href="#%E8%B0%88%E4%B8%80%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F">2.谈一谈分布式 ID 生成方案的了解？</a></h4><h3 id="怎么设计一个大文件上传的功能？"><a href="#怎么设计一个大文件上传的功能？" class="headerlink" title="怎么设计一个大文件上传的功能？"></a>怎么设计一个大文件上传的功能？</h3><p>首先如果是大文件上传，考虑到网络不稳定容易造成上传失败，或者需要做断点续传功能，是不是对整个文件直接进行上传的。</p>
<h4 id="1-计算-hash"><a href="#1-计算-hash" class="headerlink" title="1.计算 hash"></a>1.计算 hash</h4><p>首先是让前端对大文件计算 hash 值，主要是用于后端去判断这个文件在服务器上是否已经存在，其次是这个 hash 值可以作为上传文件的一个标识。<br>如果是直接对整个文件计算 hash 值，文件过大时，可能会比较慢，通常是对文件进行抽样计算。根据 hash 值判断文件是否在后端已经存在，已存在就不进行上传了。</p>
<h5 id="影分身-Hash"><a href="#影分身-Hash" class="headerlink" title="影分身 Hash"></a>影分身 Hash</h5><p>就是把文件切分成 2M 的分片，然后对首文件+中间每个文件的首中尾取 2 个字节+尾文件，进行合并，计算合并文件的 MD5 值，作为文件的 hash 值。<br>如果这个 hash 值在后端存在：<br>说明这个文件可能存在也可能不存在。准确性不是 100%。<br>如果这个 hash 值在后端不存在：<br>说明这个文件一定不存在。准确性是 100%。<br>通过这种方式判断的思路跟布隆过滤器比较像。</p>
<h4 id="2-分片上传"><a href="#2-分片上传" class="headerlink" title="2.分片上传"></a>2.分片上传</h4><p>上传时不能一窝蜂地把所有分片文件发给后端，是把每个分片包装成一个网络请求，使用异步线程对从队列里面每次取一个分片进行上传。<br>每个分片文件都有一个唯一标识，就是 hash 值+分片编号。这样如果上传中断了，下次再进行上传时，后端可以知道哪些分片已经上传，把未上传的分片唯一标识返回给前端，前端只需要上传上次未上传的分片，这也就是断点续传。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104826733">https://zhuanlan.zhihu.com/p/104826733</a></p>
<h4 id="3-合并请求"><a href="#3-合并请求" class="headerlink" title="3.合并请求"></a>3.合并请求</h4><p>有两种方案，一种是后端记录所有分片的上传状态，当所有分片全部上传完毕后，自动合并文件。另外一种就是前端发现传完所有文件后，调用接口通知后端去合并。</p>
<h3 id="谈一谈分布式-ID-生成方案的了解？"><a href="#谈一谈分布式-ID-生成方案的了解？" class="headerlink" title="谈一谈分布式 ID 生成方案的了解？"></a>谈一谈分布式 ID 生成方案的了解？</h3><p>首先 ID 生成方案的技术考虑点：<br>唯一性：不能重复。<br>趋势递增：保证 id 作为主键时，插入数据库时的顺序性，避免随机插入。<br>单调递增：满足某些特殊业务的要求，保证后一秒请求生成的 id 比前一秒的大。<br>信息安全性：不要像 UUID 一样泄露 mac 地址，也不要像数据库主键 ID 自增完全连续，泄露每日 id 生成数据量。</p>
<h4 id="1-UUID-模式"><a href="#1-UUID-模式" class="headerlink" title="1.UUID 模式"></a>1.UUID 模式</h4><p>太长，占用存储空间过大<br>id 是字符串类型，查询成本高于数字类型<br>如果是包含 mac 地址的 UUID 会泄密</p>
<h4 id="2-单机数据库主键自增模式"><a href="#2-单机数据库主键自增模式" class="headerlink" title="2.单机数据库主键自增模式"></a>2.单机数据库主键自增模式</h4><p>id 生成的量受限于单机 MySQL 数据库的性能<br>强依赖于数据库，主从切换时容易导致重复发号<br>容易泄露 id 生成量</p>
<h4 id="3-多机数据库主键自增模式"><a href="#3-多机数据库主键自增模式" class="headerlink" title="3.多机数据库主键自增模式"></a>3.多机数据库主键自增模式</h4><p>主要是将每个数据库的步长设置为一样，但是起始值不一样，以此错开生成的 id，不便于扩展。</p>
<h5 id="4-Leaf-号段模式模式"><a href="#4-Leaf-号段模式模式" class="headerlink" title="4.Leaf 号段模式模式"></a>4.Leaf 号段模式模式</h5><p>就是数据库存储一个 maxId 代表已经发放的 id 最大值，每次将 maxId 更新为 max+step，取 step 数量的 id 发放。<br>优点： 1.便于扩展，发号性能取决于 step，可以动态调整。(Leaf 做了 Step 动态调整策略，一个号段使用时间&lt;15 分钟，就让号段拥有的 id 量 step 翻倍(直到最大阀值 100 万)，一个号段使用时间&gt;30 分钟,step 减半(直到最低阀值，初始号段 id 量)。) 2.即便主节点的宕机，短时间 Leaf 也能继续提供服务，其次是主从切换时影响较小。<br>缺点： 1.当号段里面的 id 用完时，会去数据库取新的号段，此时如果来了获取 id 的请求会需要进行等待。(Leaf 做了双 Buffer 优化，使用了双 Buffer 各存储一个号段，当一个号段使用量达到 10%后，就触发另一个号段去数据库取新号段进行更新，以便于当一个号段使用完时，可以直接切换到未使用的号段。)<br>2.id 是连续的，容易泄密。(可以自定义抛弃策略，取号段时的时候抛弃一些 id，或者定时抛弃掉一些 id。)</p>
<h4 id="5-Leaf-snowflake-模式"><a href="#5-Leaf-snowflake-模式" class="headerlink" title="5.Leaf-snowflake 模式"></a>5.Leaf-snowflake 模式</h4><p>就是沿用了 snowflake 原本的位数分配算法，1 标志位+41 位毫秒时间戳+10 位机器位+12 位序列号。使用 zookeeper 作为注册中心，id 生成服务启动时，去指路径下获取所有节点的列表，判断当前 ip+port 是否有对应的 workid 存在，有就使用，没有就往插入一个新的永久顺序节点，序号则为 workId(并且会将 workid 缓存到本地磁盘上)。运行期间每过 3s，都会上报最新的时间戳到 zookeeper。<br><strong>时钟回滚的处理：</strong><br><strong>启动时：</strong><br>zookeeper 里面会存上次生成 id 的时间戳，如果上次存储的时间戳&gt;当前系统时间戳，那么就抛出异常，启动失败。<br><strong>运行时：</strong><br>如果获取 id 时，发现上次生成 id 时的时间戳&gt;当前系统时间戳，那么说明运行时发生了时钟回滚，如果回滚的时间差&lt;5ms，就调用 wait()方法等待 10ms，然后再获取 id，时间差&gt;5ms，就抛出异常。<br>优点：<br><strong>时钟回滚优化</strong> 1.对时钟回滚做了特殊处理。<br><strong>zookeeper 弱依赖</strong> 2.为了减轻了 zookeeper 的弱依赖，实现在 zookeeper 挂了的情况下，id 生成服务也能启动，每次启动后，在本地也缓存 workid 配置，一旦启动时，发现 zookeeper 连接不上，就通过从本地缓存配置中读取 workid。(但是这样也有问题，本地缓存配置只存了 workid，没有存上次生成 id 的最大时间戳，所以一旦启动前发生了时钟回滚，或者是修改了系统时间，这样从本地缓存配置中读取 workid 生成的 id 就可能是重复的。)<br><strong>时间差优化</strong> 3.做了时间差优化，就是默认的时间戳是从 1970 年开始的，leaf 是自己选定了 2010 年的一个时间点，以此来计算时间戳，这样可以在时间位数固定的情况下，增长服务最大运行时间。在毫秒时间戳为 41 位的情况下，时间差最大是 69 年，如果以 1970 年为起点，那么最大时间就是 1970+69 年，如果以 2010 年为起点就是 2010+69 年。<br><strong>序列号优化</strong> 4.为了防止生成的 id 的序列号部分都是从 0 开始，导致插入数据库时，有数据倾斜的问题，所以每次用新的毫秒时间戳时，序列号不是从 0 开始，而是计算一个 0 到 100 之间的随机数作为起点。<br>缺点： 1.注册中心只支持 Zookeeper 2.潜在的时钟回拨问题 3.时间差过大时，生成 id 为负数。</p>
<h3 id="6-百度的-uid-generator-模式"><a href="#6-百度的-uid-generator-模式" class="headerlink" title="6.百度的 uid-generator 模式"></a>6.百度的 uid-generator 模式</h3><h4 id="默认模式"><a href="#默认模式" class="headerlink" title="默认模式"></a>默认模式</h4><p>每次启动时向数据库插入一条数据，这行数据的主键是自增的，主键 id 就是 workId，<br>因为默认是 snowflake 算法是<strong>1 标志位+41 位时间戳+10 位机器号+12 位序列号</strong>，<br>因为百度的是每次启动都获取新的机器号，所以它修改了这些位数配比，是<br><strong>1 标志位+28 位的秒级时间差+22 位的机器号+13 位的序列号</strong>，所以总共支出 2 的 22 次方次启动，也就是 400 万次启动。最大服务支持时间是 2*28 次方，也就是 8.7 年。（优化点是修改位数分配，让服务时间更长，我们的位数分配是<strong>30 位秒级时间差+16 位机器号+7 位序列号</strong>，最长服务时间支持 34 年，6.5w 次机器启动，每个机器每秒 128 个并发，总共位数没有用到 64 位，只用到 53 位，这样生成的 id 转化为 10 进制更小。）<br>解决时间回拨问题：</p>
<ul>
<li>启动时时间回拨</li>
</ul>
<p>因为是每次都用新的机器号，所以当前机器号都是之前没有的，所以即便时间戳回拨也不影响。</p>
<ul>
<li>运行时时间回拨</li>
</ul>
<p>会使用 lastSecond 来记录上次生成 id 的时间戳，如果当前时间戳比 lastSecond 还小，就抛出异常。（优化点就是<strong>回拨时间差较小时进行等待</strong>，较长时再抛出异常。）<br>缺点： 1.默认的最大服务年限太短，只有 8 年。 2.回拨时间差较小时也是抛出异常，没有额外的判断逻辑。 3.没有像 Leaf 一样做序列号优化，可能生成的 id 序列号部分都是从 0 开始的多一些，可能会存在数据倾斜的问题。</p>
<h4 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h4><p>主要继承自默认模式，只是用一个环形数组来存储生成好的 id，每次去环形数组中去，默认大小是 2 的 13 次方，8192。这种模式使用的时间取得不是实时的系统时间，而且使用启动时的时间，每次生成一组 id 时，对之前保存的时间+1。<br><strong>阀值检测预填充</strong>：取 id 时，发现可用 id 数小于阀值 50%时，就对后面已经使用的 id 进行再填充。<br><strong>定期填充</strong>：每 5 分钟定期会去检查环形数组中 id 使用情况，然后生成一组最大序列号个数的 id(默认是 8192 个)，然后进行填充，多的直接丢弃掉。<br><strong>缺点</strong>：<br>1.id 只有在定期填充时，会丢弃掉一些 id，其他情况下，id 是完全连续的。假如每次使用量比较大，大部分时候都是 5 分钟内能用掉 50%的话，那么就就不会触发定期填充，也没有 id 丢弃，导致 id 会一直连续，容易泄露数据信息，所以最好自定义丢弃逻辑。 2.其次是 id 跟生成 id 时系统的时间戳无关了，可能无法满足一些特殊业务的需求。</p>
<h3 id="自己的方案"><a href="#自己的方案" class="headerlink" title="自己的方案"></a>自己的方案</h3><p>我们自己的主要是根据 uid-generator 来做的，因为只是启动的时候依赖数据库，不需要引进新的依赖。做的优化主要是修改了位数分配，使得支持最大服务年限更长，30 位时间差+16 位机器号+7 位序列号。做了时钟回拨优化，回拨差值较小时进行等待。以及做了序列号丢弃的优化。</p>
<h3 id="谈一谈你对分布式事务的理解？"><a href="#谈一谈你对分布式事务的理解？" class="headerlink" title="谈一谈你对分布式事务的理解？"></a>谈一谈你对分布式事务的理解？</h3><h4 id="2PC-方案-2-阶段提交制"><a href="#2PC-方案-2-阶段提交制" class="headerlink" title="2PC 方案(2 阶段提交制)"></a>2PC 方案(2 阶段提交制)</h4><p>这种方案就是引入了一个协调者，主要分为 prepare 和 commit 两个阶段，在第一阶段其实就是协调者给各个业务系统发送命令，业务系统收到后，就会开始执行这个子事务的具体操作，然后给协调者反馈，子事务执行成功还是失败，发送后，业务系统就会同步阻塞等待协调者的第二阶段的指令。<br>协调者第一阶段发送指令会进入超时等待状态，等待各个业务系统返回子事务的执行结果。<br><strong>执行成功，提交</strong><br>如果所有业务系统都执行成功了，并且协调者收到了反馈，那么就认为整个事务执行成功了，就会通知各个业务系统进行提交。<br><strong>执行失败，回滚</strong><br>如果超过时间还没有收到所有业务系统返回的结果，或者是有业务系统返回了执行失败的结果，那么协调者就认为执行失败了，通知各个业务系统进行回滚，如果此时网络出现阻塞，业务系统收不到通知，那么协调者就会一直重试发送回滚的指令。<br><strong>缺点</strong> 1.单点问题：就是一旦协调者挂掉，所有子系统都会进入阻塞等待状态。 2.数据不一致的问题：如果在第二阶段协调者给子系统发送 commit 指令时，发生了局部网络异常，就会导致接收到 commit 的指令的子系统提交事务，而没有接收到 commit 指令的子系统没有提交事务，导致数据不一致。 3.同步阻塞：由于子系统在执行阶段都是同步阻塞的，自身没有超时的机制，一旦与协调者之间的网络断开，只能一直阻塞等待，等待协调者的指令。</p>
<h4 id="3PC-三段提交制"><a href="#3PC-三段提交制" class="headerlink" title="3PC 三段提交制"></a>3PC 三段提交制</h4><p>这种方案就是分为三个阶段，canCommit，preCommit，doCommit 三个阶段。<br>第一阶段是询问阶段<br>协调者会给参与者发送 canCommit 指令，询问能否正常执行，如果满足执行的条件的话，参与者就会返回 ACK。<br>第二阶段是预执行阶段<br>协调者会给参与者发送 preCommit 指令，让参与者执行事务，但是执行完成不提交，参与者执行成功后会给协调者发送 ACK。<br>第三阶段就是提交阶段<br>协调者如果收到所有参与者给他返回执行成功的 ACK，那么他就会给所有协调者发送 doCommit 指令，让参与者提交。如果在第二阶段有一个参与者执行失败，给协调返回执行失败的结果，那么在第三阶段，协调者就会给参与者发送 Abort 指令，让参与者回滚。</p>
<p><strong>与 2PC 的区别：</strong><br>1.3pc 是一个非阻塞的协议，为参与者引入了超时机制，在第一阶段或者第二阶段，参与者等待协调者的指令超时了，会进行回滚，第三阶段等待协调者的指令超时了，会进行自动提交。而 2pc 协议，如果协调者一直没有给参与者发指令，导致超时，参与者会一直进行阻塞等待。<br>2.2pc 协议里面，第二阶段协调者挂了，选举出新的协调者是不知道参与者执行的事务是提交事务还是回滚事务。3pc 里面到了第三阶段那么一定是执行提交事务。<br><strong>3pc 的问题：</strong><br>第三阶段如果发送的是 abort 回滚指令，假设有些参与者由于网络原因没有收到指令，超时后会进行自行提交事务，那么也会导致数据不一致的问题。<br><a target="_blank" rel="noopener" href="https://honeypps.com/architect/introduction-of-distributed-transaction/">https://honeypps.com/architect/introduction-of-distributed-transaction/</a><br><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2018/08/rocketmq-4.3-release">https://www.infoq.cn/article/2018/08/rocketmq-4.3-release</a></p>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>TCC 分为 Try 预留阶段，Confirm 确认阶段，Cancel 撤销阶段三个阶段。<br>比如某个事务需要 A，B，C 三个业务系统各自执行一些操作，那么事务管理器会发送 Try 指令，会让 A，B，C 三个业务系统各自去申请执行操作所需的一些资源，冻结库存之类的。A，B，C 预留资源成功了就会通知事务管理器 Try 阶段执行成功了。那么事务管理器就会发送 Confirm 指令给三个业务系统，告诉他们进入到 Confirm 阶段，让 A，B，C 业务系统各自执行自己真正的事务操作。如果三个业务系统都执行成功，那么事务管理器就认为执行成功，如果有一个失败那么事务管理器就认为执行失败了，会通知每个业务执行 Cancel 操作，进行回滚。<br>（万一某个服务的 Cancel 或者 Confirm 逻辑执行一直失败怎么办呢？<br>Cancel 或者 Confirm 一直没成功，会不停的重试调用它的 Cancel 或者 Confirm 逻辑，务必要它成功。）<br>TCC 框架主要有 ByteTCC，TCC-transaction，Himly。<br>缺点： 1.侵入性太强，每个业务系统还需要写 Cancel 对应的数据回滚相关的逻辑代码。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jajian/p/10014145.html">https://www.cnblogs.com/jajian/p/10014145.html</a></p>
<h5 id="本地消息表法"><a href="#本地消息表法" class="headerlink" title="本地消息表法"></a>本地消息表法</h5><p>就是上游服务先执行操作，将操作记录到数据库中的本地消息表，并且此时这条操作记录的 status 设置为 0，也就是未通知成功。然后将操作记录封装成 Kafka 消息发送到消息队列，下游系统接受到，进行消费，然后消费成功后调用上游服务的接口，通知他消费成功了，上游系统将本地消息表中这条记录的 status 设置为 1，代表通知成功。<br>并且上游系统会定时扫描本地消息表，将 status 为 0 的操作记录，封装成 Kafka 消息，发送到消息队列。<br>并且下游系统是通过消息中操作记录的主键 id 来防止不重复消费，保证幂等性的。就是消费消息时，发送操作记录的 id 已经在数据库中存在了，就代表之前已经处理过了，不处理这条消息了。</p>
<h5 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h5><p>RocketMQ 在 4.3 以后，增加了对分布式事务的支持，就是将事务的执行状态保存在 RocketMQ 中，由 RocketMQ 去负责将 commit 状态的消息推送给下游系统。</p>
<p>1.上游系统发送 prepare 消息到 RocketMQ。<br>2.prepare 消息发送到 RocketMQ 成功后，上游系统开始执行本地事务。 3.如果上游系统本地事务执行成功，会发送 commit 消息到 RocketMQ，RocketMQ 会将这个消息提交，推送给消费者（也就是下游系统）。如果上游系统本地事务执行失败，会发送 rollback 消息到 RocketMQ，RocketMQ 会将这个消息撤销，不推送给消费者。 4.如果一个 prepare 消息一直没有接受到上游系统的 commit 或者 rollback 指令，这样就判定 prepare 消息超时了，RocketMQ 会去查询上游系统的这个事务的执行状态，是成功了，还是失败，做下一步的处理。<br><strong>底层实现原理</strong><br>RocketMQ 使用了 Half topic 队列来保存所有 prepare 消息，使用 Operation Topic 队列来保存 commit 消息和 rollback 消息。这样通过 Operation Topic 就知道哪些消息 commit 了，可以推送给消费者，哪些消息 rollback 了，不需要推送给消费者。以及那些在 Half topic 中有，在 Operation Topic 中没有的消息，就是事务超时的消息。<br><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2018/08/rocketmq-4.3-release">https://www.infoq.cn/article/2018/08/rocketmq-4.3-release</a></p>
<h5 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h5><p>业务系统 A 执行本地事务完成后，发送个消息到 MQ，有一个个专门消费 MQ 的服务，来消费 MQ 的消息，消费完会在数据库中记录下来(或者放入到内存队列)，之后就一直调用系统 B 的接口，要是系统 B 执行成功就提交，执行失败或者调用超时就一直重试，直到业务系统 B 执行成功。</p>
<h3 id="如何设计秒杀系统？"><a href="#如何设计秒杀系统？" class="headerlink" title="如何设计秒杀系统？"></a>如何设计秒杀系统？</h3><p>1.前端页面<br>提前把静态资源部署到 CDN，减少静态资源访问的压力，其次是可以为静态资源的 header 设置成强缓存 cache-control，2 分钟后才过期，这样当第一次请求完静态资源后，再次刷新时，就会使用浏览器里面的缓存的静态资源，而不是再发请求。<br>2.nginx 层面<br>使用 limit_req_zone 模块针对用户 id 为 key，进行限流，放在同一个用户恶意发起多个请求，限制每个用户每 5 分钟只能请求 100 次接口。 3.业务系统设置限流熔断<br>当业务系统收到的请求达到一定限制后，停止接受请求，可以使用 hystrix 进行限流。如果是秒杀商品，当 Redis 里面存的商品库存减完时，就对所有用户返回统一的状态码，告诉前端商品被抢光了，不再进行后面的业务逻辑。 4.使用消息队列削峰<br>就是如果秒杀请求对应的业务逻辑处理时间如果过长，例如减库存，生成订单等，业务系统可以先将用户的秒杀请求封装成 Kafka 消息，发送到消息队列，由其他业务系统消费 Kafka 消息，完成生成订单等耗时操作。<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54895548/answer/1352510403">https://www.zhihu.com/question/54895548/answer/1352510403</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2022/06/01/yuque/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/" data-id="cl3zp2b6o002c1w7sfu2i2e69" data-title="系统设计相关" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/分布式事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/15/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2022-05-15T13:08:37.000Z" itemprop="datePublished">2022-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/15/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare/index.html?id=8b17d49a6bc082e9c33fcf94969b5804&type=note&_time=1652606660211">别人的笔记</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183753774">面试必问：分布式事务六种解决方案</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Moqp8DnOYy4lHQsw-iLC_A">令人头疼的分布式事务，1 次讲明白！</a><br>TCC 的问题：<br>业务侵入多，开发工作量大<br>更多的网络交互开销，降低效率<br>TCC 的优化：<br>性能与安全取舍，将非核心交易剔除，使用简单重试<br>TCC 协调服务使用内存存储数据，异步同步数据库做备份<br>删除 TCC 协调服务，由发起服务记录对应的数据，减少一次网络通信</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2022/05/15/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" data-id="cl3zp2b63001a1w7s2hfqc3id" data-title="分布式事务" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/问题以及方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/15/yuque/%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2022-05-15T09:14:56.000Z" itemprop="datePublished">2022-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/15/yuque/%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/">问题以及方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>缓存雪崩和缓存击穿主要是数据不在缓存上，而缓存穿透是数据既不在缓存上，也不在数据上。<br><strong>缓存穿透的解决方法</strong>：</p>
<ul>
<li>入口进行合法性验证，过滤恶意请求</li>
<li>缓存空值或者缺省值</li>
<li>使用布隆过滤器快速判断</li>
</ul>
<p><strong>缓存击穿的解决方法</strong>：</p>
<ul>
<li>不设置过期时间</li>
<li>加互斥锁</li>
</ul>
<p><strong>缓存雪崩的解决方法</strong>：</p>
<ul>
<li>给过期时间加上小的随机数</li>
<li>服务降级</li>
<li>服务熔断</li>
<li>请求限流</li>
<li>redis 设置主从集群</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2022/05/15/yuque/%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/" data-id="cl3zp2b6s002m1w7sdu679ly6" data-title="问题以及方案" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/缓存和数据库双写不一致" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/15/yuque/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/" class="article-date">
  <time class="dt-published" datetime="2022-05-15T07:31:22.000Z" itemprop="datePublished">2022-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/15/yuque/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/">缓存和数据库双写不一致</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p>先查询缓存，命中即返回，未命中则查询数据库，然后更新缓存数据。</p>
<h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><p>两个大方案，Cache Aside Pattern 和 缓存延时双删</p>
<h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a><strong>Cache Aside Pattern</strong></h3><h4 id="先删除缓存再更新数据"><a href="#先删除缓存再更新数据" class="headerlink" title="先删除缓存再更新数据"></a>先删除缓存再更新数据</h4><p>可以避免缓存删除失败后，缓存和数据库数据不一致的问题。<br>问题：当删除缓存后，数据还未更新成功的时间窗口内，如果发生数据查询，则缓存内的数据都为老数据。</p>
<h4 id="先更新数据再删除缓存"><a href="#先更新数据再删除缓存" class="headerlink" title="先更新数据再删除缓存"></a>先更新数据再删除缓存</h4><p>facebook 就是这种方式，可以避免更新数据的时间窗口内，数据查询不是最新数据的问题。<br>问题：当删除缓存失败时，缓存内的数据将在下一次数据更新前都是老数据。</p>
<h3 id="缓存延时双删"><a href="#缓存延时双删" class="headerlink" title="缓存延时双删"></a>缓存延时双删</h3><p>更新数据库后删除缓存，然后隔一段时间异步再次删除缓存。<br>可以通过消息队列订阅 MySql 的 binlog 日志(现成的中间件 canal)，也可以通过程序启动异步线程去执行删除。<br>问题：当缓存删除失败后，会出现短时间的不一致，不一致的时间窗口为延时删除的延迟时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2022/05/15/yuque/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/" data-id="cl3zp2b6p002f1w7sgxab9b3z" data-title="缓存和数据库双写不一致" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/短链接系统设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/14/yuque/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2022-05-14T07:19:15.000Z" itemprop="datePublished">2022-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/14/yuque/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">短链接系统设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://hufangyun.com/2017/short-url/">https://hufangyun.com/2017/short-url/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2022/05/14/yuque/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" data-id="cl3zp2b6l00251w7s62gb5901" data-title="短链接系统设计" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/Mysql实战原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/12/yuque/Mysql%E5%AE%9E%E6%88%98%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-05-12T10:48:24.000Z" itemprop="datePublished">2022-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/12/yuque/Mysql%E5%AE%9E%E6%88%98%E5%8E%9F%E7%90%86/">Mysql实战原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2022/xmind/1982501/1652352553686-2cef156d-fb34-41cc-b724-7fda8de2c6f9.xmind">Mysql 实战原理.xmind</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2022/05/12/yuque/Mysql%E5%AE%9E%E6%88%98%E5%8E%9F%E7%90%86/" data-id="cl3zp2b5u000r1w7s9tde5z3h" data-title="Mysql实战原理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Object" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/18/Object/" class="article-date">
  <time class="dt-published" datetime="2021-07-18T14:21:40.000Z" itemprop="datePublished">2021-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/18/Object/">异常</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>为什么wait和notify方法在object中</p>
<blockquote>
<p><strong>wait和notify需要在synchronized同步方法中才能执行，而synchronized加锁的是对象的markword指向的moniter对象，每个对象的对象头markword中保留了锁标志位和指向monitor对象的起始地址。每个对象都可以上锁，所以需要在object中，而不是thread中。</strong></p>
</blockquote>
<ol>
<li><p>wait 和 notify 不仅仅是普通方法或同步工具，更重要的是它们是 <strong>Java 中两个线程之间的通信机制</strong>。对语言设计者而言, 如果不能通过 Java 关键字(例如 synchronized)实现通信此机制，同时又要确保这个机制对每个对象可用, 那么 Object 类则是的合理的声明位置。记住<strong>同步</strong>和<strong>等待通知</strong>是两个不同的领域，不要把它们看成是相同的或相关的。同步是提供互斥并确保 Java 类的线程安全，而 <strong>wait 和 notify 是两个线程之间的通信机制</strong>。</p>
</li>
<li><p><strong>每个对象都可上锁</strong>，这是在 Object 类而不是 Thread 类中声明 wait 和 notify 的另一个原因。</p>
</li>
<li><p>在 Java 中，为了进入代码的临界区，线程需要锁定并等待锁，他们不知道哪些线程持有锁，而只是知道锁被某个线程持有， 并且需要等待以取得锁, 而不是去了解哪个线程在同步块内，并请求它们释放锁。</p>
</li>
<li><p>Java 是基于 Hoare 的监视器的思想(<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/...)%E3%80%82%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E7%9B%91%E8%A7%86%E5%99%A8%E3%80%82">http://en.wikipedia.org/wiki/...)。在Java中，所有对象都有一个监视器。</a></p>
</li>
</ol>
<p>线程在监视器上等待，为执行等待，我们需要2个参数：</p>
<ul>
<li>一个线程</li>
<li>一个监视器(任何对象)</li>
</ul>
<p>在 Java 设计中，线程不能被指定，它总是运行当前代码的线程。但是，我们可以指定监视器(这是我们称之为等待的对象)。这是一个很好的设计，因为如果我们可以让任何其他线程在所需的监视器上等待，这将导致“入侵”，影响线程执行顺序，导致在设计并发程序时会遇到困难。请记住，在 Java 中，所有在另一个线程的执行中造成入侵的操作都被弃用了(例如 Thread.stop 方法)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2021/07/18/Object/" data-id="cl3zm33vq0002ja7s4dutdpkx" data-title="异常" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/异常" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/12/yuque/%E5%BC%82%E5%B8%B8/" class="article-date">
  <time class="dt-published" datetime="2021-05-12T02:56:49.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/12/yuque/%E5%BC%82%E5%B8%B8/">异常</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1982501/1620789035739-0afcecea-acd3-46ad-ab90-1dd26a7fe21a.jpeg"></p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ol>
<li>尽量不要捕获或者抛出通用异常，而是使用特定异常。</li>
<li>不要生吞异常。这样会使程序发生异常时难以定位。</li>
<li>不要对大段代码使用 try-catch，也不要频繁使用。<ol>
<li>try-catch 代码段会产生额外的性能开销</li>
<li>每次抛出异常，JVM 都会对当前栈进行快照，性能开销比较重</li>
</ol>
</li>
<li>不要使用 printStackTrace()打印异常<ol>
<li>这个方法会输出到 standard error stream，复杂的系统中，这不是一个合适的输出选项</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2021/05/12/yuque/%E5%BC%82%E5%B8%B8/" data-id="cl3zp2b6b001q1w7s4jcefzgf" data-title="异常" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/08/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-04-08T03:25:01.000Z" itemprop="datePublished">2021-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/08/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.nlark.com/yuque/0/2021/png/1982501/1617852312575-9e7c9a72-065f-429d-aa38-92e2e3e48f45.png#align=left&display=inline&height=1952&margin=%5Bobject%20Object%5D&name=f3262ef8152517d3b11bfc3f2d2b12d3.png&originHeight=3903&originWidth=5013&size=899627&status=done&style=none&width=2506.5" alt="f3262ef8152517d3b11bfc3f2d2b12d3.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2021/04/08/yuque/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cl3zp2b6q002h1w7sdlitaeqz" data-title="设计模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%80%E5%8E%86/" rel="tag">简历</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/%E7%AE%80%E5%8E%86/" style="font-size: 10px;">简历</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/">个人简历</a>
          </li>
        
          <li>
            <a href="/2022/06/01/yuque/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/">系统设计相关</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/">问题以及方案</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/">缓存和数据库双写不一致</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>