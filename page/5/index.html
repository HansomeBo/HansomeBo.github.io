<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>HandsomeBo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="HandsomeBo">
<meta property="og:url" content="http://handsomebo.com/page/5/index.html">
<meta property="og:site_name" content="HandsomeBo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HandsomeBo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HandsomeBo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://handsomebo.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-yuque/冷知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/07/yuque/%E5%86%B7%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2020-12-07T14:08:18.000Z" itemprop="datePublished">2020-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/07/yuque/%E5%86%B7%E7%9F%A5%E8%AF%86/">冷知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 32 位的虚拟机中，long 和 double 类型的简单赋值操作不是原子性的，因为这两个数据类型是 64 位的，多线程同时操作时可能会同时变更高低 32 位，导致结果不正确。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/12/07/yuque/%E5%86%B7%E7%9F%A5%E8%AF%86/" data-id="cl3zp2b6200191w7s5qdg58rx" data-title="冷知识" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/生产OOM分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/07/yuque/%E7%94%9F%E4%BA%A7OOM%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2020-12-07T12:24:45.000Z" itemprop="datePublished">2020-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/07/yuque/%E7%94%9F%E4%BA%A7OOM%E5%88%86%E6%9E%90/">生产OOM分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="如何定位哪里产生了-OOM"><a href="#如何定位哪里产生了-OOM" class="headerlink" title="如何定位哪里产生了 OOM"></a>如何定位哪里产生了 OOM</h2><p>服务启动时配置参数，XX:+HeapDumpOnOutOfMemoryError，在服务因为 OOM 死掉时会导出 HeapDump 文件。<br>使用 mat 分析 dump 文件，mat 的 LeakSupports 中有 OOM 的具体分析。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/shenzhou_yh/article/details/88910031">利用性能工具 MAT 分析 OOM</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/12/07/yuque/%E7%94%9F%E4%BA%A7OOM%E5%88%86%E6%9E%90/" data-id="cl3zp2b6k00221w7s1um3dmiy" data-title="生产OOM分析" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/底层数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/07/yuque/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2020-12-07T08:36:23.000Z" itemprop="datePublished">2020-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/07/yuque/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">底层数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://note.youdao.com/yws/public/resource/46a41f2c9f13c2115abe4b7529dbc33b/xmlnote/D84A7DA2F048449BBCE990D121868C06/5980#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=419&status=done&style=none&width=419"><br>redis 对外展现五种数据类型，string（字符串），hash（哈希）、list（列表）、set（集合）、zset（有序集合）。每种数据结构，redis 都提供了不同的内部编码实现方式（内部编码可以通过 object encoding key 查看），以便使用不同的场景  <br><strong>1、string</strong><br>1）int：8 个字节的长整型，如果一个字符串保存的类型是整数值，并且这个值可以 用 long 类型来表示，name 字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面，并将字符串对象的编码设置为 int。<br>2）embstr：小于等于 39 个字节的字符串，embstr 编码是专门用于保存短字符串的优化编码方式。相比 raw 有如下好处：<br>A、embstr 编码将创建字符串对象所需的空间分配的次数从 raw 编码的两次降低为一次。<br>B、释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码对象的字符串对象需要调用两次内存释放函数<br>C、因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw 编码的字符串对象能更好地利用缓存带来的优势。<br>3）raw：大于 39 个字节的字符串，用简单动态字符串（SDS）来保存，将这个字符串的对象编码设置为 raw。<br>ps:<br>sds 相比传统字符串的优点：因为保存了长度字段常 o(1)时间复杂度获取字符串长度；杜绝缓冲区溢出；减少修改字符串时带来的内存重分配次数；<br><strong>2、hash 哈希的内部编码</strong><br>1）ziplist（压缩列表）：当哈希类型元素小于 has-max-ziplist-entries 配置（默认 512 个），同事所有值都小于 hash-max-ziplist-value 配置（默认 64 个字节）时，redis 会使用 ziplist 作为哈希的内部实现。ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比 hashtable 更加优秀<br>2）hashtable（哈希表）：当哈希类型无法满足 ziplist 的条件时，redis 会使用 hashtable 作为哈希的内部实现。因为 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为 o（1）<br><strong>3、list 列表的内部编码</strong><br>1）ziplist（压缩列表）<br>2）linkedlist（链表）：当列表类型无法满足条件的时候，redis 会使用 linkedlist 作为列表的内部实现<br><strong>4、set 集合</strong><br>1）intset（整数集合）：当集合中的元素都是整数且元素个数小于 set-max-intset-entries 配置（默认 512 个）是，redis 会选 intset 作为集合的内部实现，从而减少内存使用<br>2）hashtable：当集合元素无法满足 intset 的条件时，redis 会使用 hashtable 作为集合的内部实现<br><strong>5、zset 有序集合的内部编码</strong><br>1）ziplist：<br>2）skiplist（跳跃表）：当 ziplist 条件不满足的时候，有序集合会使用 skiplist 作为内部 实现，因为 ziplist 的读写效率会下降<br>string int 如果保存的是整数值，用内部编码使用 int，效率高 embstr 少于 39 字节的字符串，只需要一次分配内存，一次释放内存 raw 大于 39 字节的字符串，需要两次分配内存，两次释放内存 hash ziplist 压缩列表，更紧凑实现多元素的连续存储，节省内存，当元素个数小于 512，value 长度小于 64 字节 hashtable 当 ziplist 不满足条件时会使用 hashtable，时间复杂度 O(1) list ziplist 压缩列表，更紧凑实现多元素的连续存储，节省内存，当元素个数小于 512，value 长度小于 64 字节 linklist 当 ziplist 不满足条件时会使用 linklist set intset 当集合中的元素都是整数，且元素个数小于 512，会使用 intset 内部编码，减少内存使用 hashtable 当 intset 不满足条件时，会使用 hashtable zset ziplist 压缩列表，更紧凑实现多元素的连续存储，节省内存，当元素个数小于 512，value 长度小于 64 字节 skiplist 当 ziplist 不满足条件时，使用跳跃表<br>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fst438060684/article/details/80563186">https://blog.csdn.net/fst438060684/article/details/80563186</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/12/07/yuque/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cl3zp2b6b001p1w7s81sv5ace" data-title="底层数据结构" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/调优原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/05/yuque/%E8%B0%83%E4%BC%98%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-12-05T06:54:42.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/05/yuque/%E8%B0%83%E4%BC%98%E5%8E%9F%E7%90%86/">调优原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="缓冲-Buffer"><a href="#缓冲-Buffer" class="headerlink" title="缓冲 Buffer"></a>缓冲 Buffer</h2><p>单机-IOBuffer<br>集群-消息队列</p>
<h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h2><p>单机-页缓存<br>集群-Redis</p>
<h2 id="复用-Pool"><a href="#复用-Pool" class="headerlink" title="复用 Pool"></a>复用 Pool</h2><p>连接池、线程池、常量池</p>
<h2 id="分治-Sharding"><a href="#分治-Sharding" class="headerlink" title="分治 Sharding"></a>分治 Sharding</h2><p>数据库、ES</p>
<h2 id="粘性-Sticky"><a href="#粘性-Sticky" class="headerlink" title="粘性 Sticky"></a>粘性 Sticky</h2><p>TreadLocal、相同特征数据路由到同一台机器</p>
<h2 id="权衡-Balance"><a href="#权衡-Balance" class="headerlink" title="权衡 Balance"></a>权衡 Balance</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/12/05/yuque/%E8%B0%83%E4%BC%98%E5%8E%9F%E7%90%86/" data-id="cl3zp2b6r002i1w7s697mb1c8" data-title="调优原理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/GC和GC Tuning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/04/yuque/GC%E5%92%8CGC%20Tuning/" class="article-date">
  <time class="dt-published" datetime="2020-12-04T02:58:19.000Z" itemprop="datePublished">2020-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/04/yuque/GC%E5%92%8CGC%20Tuning/">GC和GC Tuning</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>作者：马士兵教育 <a target="_blank" rel="noopener" href="http://mashibing.com/">http://mashibing.com</a></p>
<h3 id="GC-的基础知识"><a href="#GC-的基础知识" class="headerlink" title="GC 的基础知识"></a>GC 的基础知识</h3><h4 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1.什么是垃圾"></a>1.什么是垃圾</h4><blockquote>
<p>C 语言申请内存：malloc free</p>
</blockquote>
<blockquote>
<p>C++： new delete</p>
</blockquote>
<blockquote>
<p>c&#x2F;C++ 手动回收内存</p>
</blockquote>
<blockquote>
<p>Java: new ？</p>
</blockquote>
<blockquote>
<p>自动内存回收，编程上简单，系统不容易出错，手动释放内存，容易出两种类型的问题：</p>
</blockquote>
<blockquote>
<ol>
<li>忘记回收</li>
<li>多次回收</li>
</ol>
</blockquote>
<p>没有任何引用指向的一个对象或者多个对象（循环引用）</p>
<h4 id="2-如何定位垃圾"><a href="#2-如何定位垃圾" class="headerlink" title="2.如何定位垃圾"></a>2.如何定位垃圾</h4><ol>
<li>引用计数（ReferenceCount）</li>
<li>根可达算法(RootSearching)</li>
</ol>
<h4 id="3-常见的垃圾回收算法"><a href="#3-常见的垃圾回收算法" class="headerlink" title="3.常见的垃圾回收算法"></a>3.常见的垃圾回收算法</h4><ol>
<li>标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描）</li>
<li>拷贝算法 (copying) - 没有碎片，浪费空间</li>
<li>标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）</li>
</ol>
<h4 id="4-JVM-内存分代模型（用于分代垃圾回收算法）"><a href="#4-JVM-内存分代模型（用于分代垃圾回收算法）" class="headerlink" title="4.JVM 内存分代模型（用于分代垃圾回收算法）"></a>4.JVM 内存分代模型（用于分代垃圾回收算法）</h4><ol>
<li>部分垃圾回收器使用的模型<blockquote>
<p>除 Epsilon ZGC Shenandoah 之外的 GC 都是使用逻辑分代模型</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>G1 是逻辑分代，物理不分代</p>
</blockquote>
<blockquote>
<p>除此之外不仅逻辑分代，而且物理分代</p>
</blockquote>
<ol start="2">
<li><p>新生代 + 老年代 + 永久代（1.7）Perm Generation&#x2F; 元数据区(1.8) Metaspace</p>
<ol>
<li>永久代 元数据 - Class</li>
<li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）</li>
<li>字符串常量 1.7 - 永久代，1.8 - 堆</li>
<li>MethodArea 逻辑概念 - 永久代、元数据</li>
</ol>
</li>
<li><p>新生代 &#x3D; Eden + 2 个 suvivor 区</p>
<ol>
<li>YGC 回收之后，大多数的对象会被回收，活着的进入 s0</li>
<li>再次 YGC，活着的对象 eden + s0 -&gt; s1</li>
<li>再次 YGC，eden + s1 -&gt; s0</li>
<li>年龄足够 -&gt; 老年代 （15 CMS 6）</li>
<li>s 区装不下 -&gt; 老年代</li>
</ol>
</li>
<li><p>老年代</p>
<ol>
<li>顽固分子</li>
<li>老年代满了 FGC Full GC</li>
</ol>
</li>
<li><p>GC Tuning (Generation)</p>
<ol>
<li>尽量减少 FGC</li>
<li>MinorGC &#x3D; YGC</li>
<li>MajorGC &#x3D; FGC</li>
</ol>
</li>
<li><p>对象分配过程图</p>
</li>
</ol>
<p><img src="/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3.png#alt="></p>
<ol start="7">
<li>动态年龄：（不重要）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/989d3b06a49d">https://www.jianshu.com/p/989d3b06a49d</a></p>
<ol start="8">
<li>分配担保：（不重要）</li>
</ol>
<p>YGC 期间 survivor 区空间不够了 空间担保直接进入老年代</p>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1082730">https://cloud.tencent.com/developer/article/1082730</a></p>
<h4 id="5-常见的垃圾回收器"><a href="#5-常见的垃圾回收器" class="headerlink" title="5.常见的垃圾回收器"></a>5.常见的垃圾回收器</h4><p><img src="/%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png#alt=%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"></p>
<ol>
<li>垃圾回收器的发展路线，是随着内存越来越大的过程而演进</li>
</ol>
<p>从分代算法演化到不分代算法</p>
<p>Serial 算法 几十兆</p>
<p>Parallel 算法 几个 G</p>
<p>CMS 几十个 G  - 承上启下，开始并发回收 -</p>
<p>.- 三色标记 - 2. JDK 诞生 Serial 追随 提高效率，诞生了 PS，为了配合 CMS，诞生了 PN，CMS 是 1.4 版本后期引入，CMS 是里程碑式的 GC，它开启了并发回收的过程，但是 CMS 毛病较多，因此目前任何一个 JDK 版本默认是 CMS</p>
<p>并发垃圾回收是因为无法忍受 STW 3. Serial 年轻代 串行回收 4. PS 年轻代 并行回收 5. ParNew 年轻代 配合 CMS 的并行回收 6. SerialOld 7. ParallelOld 8. ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低 STW 的时间(200ms)</p>
<p>CMS 问题比较多，所以现在没有一个版本默认是 CMS，只能手工指定</p>
<p>CMS 既然是 MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS 的老年代分配对象分配不下的时候，使用 SerialOld 进行老年代回收</p>
<p>想象一下：</p>
<p>PS + PO -&gt; 加内存 换垃圾回收器 -&gt; PN + CMS + SerialOld（几个小时 - 几天的 STW）</p>
<p>几十个 G 的内存，单线程回收 -&gt; G1 + FGC 几十个 G -&gt; 上 T 内存的服务器 ZGC</p>
<p>算法：三色标记 + Incremental Update 9. G1(200ms - 10ms)</p>
<p>算法：三色标记 + SATB 10. ZGC (10ms - 1ms) PK C++</p>
<p>算法：ColoredPointers + LoadBarrier 11. Shenandoah</p>
<p>算法：ColoredPointers + WriteBarrier 12. Eplison 13. PS 和 PN 区别的延伸阅读：</p>
<p>▪<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html">https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-3D0BB91E-9BFF-4EBB-B523-14493A860E73</a> 14. 垃圾收集器跟内存大小的关系</p>
<ol>
<li>Serial 几十兆</li>
<li>PS 上百兆 - 几个 G</li>
<li>CMS - 20G</li>
<li>G1 - 上百 G</li>
<li>ZGC - 4T - 16T（JDK13）</li>
</ol>
<p>1.8 默认的垃圾回收：PS + ParallelOld</p>
<h3 id="常见垃圾回收器组合参数设定：-1-8"><a href="#常见垃圾回收器组合参数设定：-1-8" class="headerlink" title="常见垃圾回收器组合参数设定：(1.8)"></a>常见垃圾回收器组合参数设定：(1.8)</h3><ul>
<li><p>-XX:+UseSerialGC &#x3D; Serial New (DefNew) + Serial Old</p>
<ul>
<li>小型程序。默认情况下不会是这种选项，HotSpot 会根据计算及配置和 JDK 版本自动选择收集器</li>
</ul>
</li>
<li><p>-XX:+UseParNewGC &#x3D; ParNew + SerialOld</p>
<ul>
<li>这个组合已经很少用（在某些版本中已经废弃）</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future">https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future</a></li>
</ul>
</li>
<li><p>-XX:+UseConc(urrent)MarkSweepGC &#x3D; ParNew + CMS + Serial Old</p>
</li>
<li><p>-XX:+UseParallelGC &#x3D; Parallel Scavenge + Parallel Old (1.8 默认) 【PS + SerialOld】</p>
</li>
<li><p>-XX:+UseParallelOldGC &#x3D; Parallel Scavenge + Parallel Old</p>
</li>
<li><p>-XX:+UseG1GC &#x3D; G1</p>
</li>
<li><p>Linux 中没找到默认 GC 的查看方法，而 windows 中会打印 UseParallelGC</p>
<ul>
<li>java +XX:+PrintCommandLineFlags -version</li>
<li>通过 GC 的日志来分辨</li>
</ul>
</li>
<li><p>Linux 下 1.8 版本默认的垃圾回收器到底是什么？</p>
<ul>
<li>1.8.0_181 默认（看不出来）Copy MarkCompact</li>
<li>1.8.0_222 默认 PS + PO</li>
</ul>
</li>
</ul>
<h3 id="JVM-调优第一步，了解-JVM-常用命令行参数"><a href="#JVM-调优第一步，了解-JVM-常用命令行参数" class="headerlink" title="JVM 调优第一步，了解 JVM 常用命令行参数"></a>JVM 调优第一步，了解 JVM 常用命令行参数</h3><ul>
<li><p>JVM 的命令行参数参考：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
</li>
<li><p>HotSpot 参数分类</p>
<blockquote>
<p>标准： - 开头，所有的 HotSpot 都支持</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>非标准：-X 开头，特定版本 HotSpot 支持特定命令</p>
</blockquote>
<blockquote>
<p>不稳定：-XX 开头，下个版本可能取消</p>
</blockquote>
<p>java -version</p>
<p>java -X</p>
<p>java -XX:+PrintFlagsWithComments &#x2F;&#x2F;只有 debug 版本能用</p>
<p>试验用程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloGC</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;HelloGC!&quot;</span>);</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">      <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">      list.add(b);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 区分概念：内存泄漏memory leak，内存溢出out of memory</span><br><span class="line">2. java -XX:+PrintCommandLineFlags HelloGC</span><br><span class="line">3. java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC  HelloGC</span><br><span class="line">   PrintGCDetails PrintGCTimeStamps PrintGCCauses</span><br><span class="line">4. java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC</span><br><span class="line">5. java -XX:+PrintFlagsInitial 默认参数值</span><br><span class="line">6. java -XX:+PrintFlagsFinal 最终参数值</span><br><span class="line">7. java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数</span><br><span class="line">8. java -XX:+PrintFlagsFinal -version |grep GC</span><br><span class="line">9. java -XX:+PrintFlagsFinal -version | wc -l</span><br><span class="line">   共728个参数</span><br><span class="line"></span><br><span class="line">### PS GC日志详解</span><br><span class="line"></span><br><span class="line">每种垃圾回收器的日志格式是不同的！</span><br><span class="line"></span><br><span class="line">PS日志格式</span><br><span class="line"></span><br><span class="line">![GC日志详解](./GC日志详解.png)</span><br><span class="line"></span><br><span class="line">heap dump部分：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">eden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000)</span><br><span class="line">                          后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址</span><br></pre></td></tr></table></figure>

<p><img src="/GCHeapDump.png#alt=GCHeapDump"></p>
<p>total &#x3D; eden + 1 个 survivor</p>
<h3 id="调优前的基础概念："><a href="#调优前的基础概念：" class="headerlink" title="调优前的基础概念："></a>调优前的基础概念：</h3><ol>
<li>吞吐量：用户代码时间 &#x2F;（用户代码执行时间 + 垃圾回收时间）</li>
<li>响应时间：STW 越短，响应时间越好</li>
</ol>
<p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p>
<p>问题：</p>
<p>科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）</p>
<p>响应时间：网站 GUI API （1.8 G1）</p>
<h3 id="什么是调优？"><a href="#什么是调优？" class="headerlink" title="什么是调优？"></a>什么是调优？</h3><ol>
<li>根据需求进行 JVM 规划和预调优</li>
<li>优化运行 JVM 运行环境（慢，卡顿）</li>
<li>解决 JVM 运行过程中出现的各种问题(OOM)</li>
</ol>
<h3 id="调优，从规划开始"><a href="#调优，从规划开始" class="headerlink" title="调优，从规划开始"></a>调优，从规划开始</h3><ul>
<li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓</p>
</li>
<li><p>无监控（压力测试，能看到结果），不调优</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器）</p>
<ol>
<li>响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）</li>
<li>吞吐量 &#x3D; 用户时间 &#x2F;( 用户时间 + GC 时间) [PS]</li>
</ol>
</li>
<li><p>选择回收器组合</p>
</li>
<li><p>计算内存需求（经验值 1.5G 16G）</p>
</li>
<li><p>选定 CPU（越高越好）</p>
</li>
<li><p>设定年代大小、升级年龄</p>
</li>
<li><p>设定日志参数</p>
<ol>
<li>-Xloggc:&#x2F;opt&#x2F;xxx&#x2F;logs&#x2F;xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;5 -XX:GCLogFileSize&#x3D;20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause</li>
<li>或者每天产生一个日志文件</li>
</ol>
</li>
<li><p>观察日志情况</p>
</li>
</ol>
</li>
<li><p>案例 1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？</p>
<blockquote>
<p>这个问题比较业余，因为很多不同的服务器配置都能支撑(1.5G 16G)</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>1 小时 360000 集中时间段， 100 个订单&#x2F;秒，（找一小时内的高峰期，1000 订单&#x2F;秒）</p>
</blockquote>
<blockquote>
<p>经验值，</p>
</blockquote>
<blockquote>
<p>非要计算：一个订单产生需要多少内存？512K * 1000 500M 内存</p>
</blockquote>
<blockquote>
<p>专业一点儿问法：要求响应时间 100ms</p>
</blockquote>
<blockquote>
<p>压测！</p>
</blockquote>
<ul>
<li>案例 2：12306 遭遇春节大规模抢票应该如何支撑？<blockquote>
<p>12306 应该是中国并发量最大的秒杀网站：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>号称并发量 100W 最高</p>
</blockquote>
<blockquote>
<p>CDN -&gt; LVS -&gt; NGINX -&gt; 业务系统 -&gt; 每台机器 1W 并发（10K 问题） 100 台机器</p>
</blockquote>
<blockquote>
<p>普通电商订单 -&gt; 下单 -&gt;订单系统（IO）减库存 -&gt;等待用户付款</p>
</blockquote>
<blockquote>
<p>12306 的一种可能的模型： 下单 -&gt; 减库存 和 订单(redis kafka) 同时异步进行 -&gt;等付款</p>
</blockquote>
<blockquote>
<p>减库存最后还会把压力压到一台服务器</p>
</blockquote>
<blockquote>
<p>可以做分布式本地库存 + 单独服务器做库存均衡</p>
</blockquote>
<blockquote>
<p>大流量的处理方法：分而治之</p>
</blockquote>
<ul>
<li>怎么得到一个事务会消耗多少内存？</li>
</ul>
<blockquote>
<ol>
<li>弄台机器，看能承受多少 TPS？是不是达到目标？扩容或调优，让它达到</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>用压测来确定</li>
</ol>
</blockquote>
<h3 id="优化环境"><a href="#优化环境" class="headerlink" title="优化环境"></a>优化环境</h3><ol>
<li>有一个 50 万 PV 的资料类网站（从磁盘提取文档到内存）原服务器 32 位，1.5G</li>
</ol>
<p>的堆，用户反馈网站比较缓慢，因此公司决定升级，新的服务器为 64 位，16G</p>
<p>的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了</p>
<ol>
<li>为什么原网站慢?</li>
</ol>
<p>很多用户浏览数据，很多数据 load 到内存，内存不足，频繁 GC，STW 长，响应时间变慢 2. 为什么会更卡顿？</p>
<p>内存越大，FGC 时间越长 3. 咋办？</p>
<p>PS -&gt; PN + CMS 或者 G1 2. 系统 CPU 经常 100%，如何调优？(面试高频)</p>
<p>CPU100%那么一定有线程在占用系统资源，</p>
<ol>
<li><p>找出哪个进程 cpu 高（top）</p>
</li>
<li><p>该进程中的哪个线程 cpu 高（top -Hp）</p>
</li>
<li><p>导出该线程的堆栈 (jstack)</p>
</li>
<li><p>查找哪个方法（栈帧）消耗时间 (jstack)</p>
</li>
<li><p>工作线程占比高 | 垃圾回收线程占比高</p>
</li>
<li><p>系统内存飙高，如何查找问题？（面试高频）</p>
<ol>
<li>导出堆内存 (jmap)</li>
<li>分析 (jhat jvisualvm mat jprofiler … )</li>
</ol>
</li>
<li><p>如何监控 JVM</p>
<ol>
<li>jstat jvisualvm jprofiler arthas top…</li>
</ol>
</li>
</ol>
<h3 id="解决-JVM-运行中的问题"><a href="#解决-JVM-运行中的问题" class="headerlink" title="解决 JVM 运行中的问题"></a>解决 JVM 运行中的问题</h3><h4 id="一个案例理解常用工具"><a href="#一个案例理解常用工具" class="headerlink" title="一个案例理解常用工具"></a>一个案例理解常用工具</h4><ol>
<li>测试代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T15_FullGC_Problem01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CardInfo</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birthdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">50</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        executor.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            modelFit();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modelFit</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CardInfo&gt; taskList = getAllCardInfo();</span><br><span class="line">        taskList.forEach(info -&gt; &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//do sth with info</span></span><br><span class="line">                info.m();</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title function_">getAllCardInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">CardInfo</span> <span class="variable">ci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CardInfo</span>();</span><br><span class="line">            taskList.add(ci);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
</li>
<li><p>一般是运维团队首先受到报警信息（CPU Memory）</p>
</li>
<li><p>top 命令观察到问题：内存不断增长 CPU 占用率居高不下</p>
</li>
<li><p>top -Hp 观察进程中的线程，哪个线程 CPU 和内存占比高</p>
</li>
<li><p>jps 定位具体 java 进程</p>
</li>
</ol>
<p>jstack 定位线程状况，重点关注：WAITING BLOCKED</p>
<p>eg.</p>
<p>waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object)</p>
<p>假如有一个进程中 100 个线程，很多线程都在 waiting on  ，一定要找到是哪个线程持有这把锁</p>
<p>怎么找？搜索 jstack dump 的信息，找 ，看哪个线程持有这把锁 RUNNABLE</p>
<p>作业：1：写一个死锁程序，用 jstack 观察 2 ：写一个程序，一个线程持有锁不释放，其他线程等待</p>
<ol start="7">
<li>为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称</li>
</ol>
<p>怎么样自定义线程池里的线程名称？（自定义 ThreadFactory）</p>
<ol start="8">
<li><p>jinfo pid</p>
</li>
<li><p>jstat -gc 动态观察 gc 情况 &#x2F; 阅读 GC 日志发现频繁 GC &#x2F; arthas 观察 &#x2F; jconsole&#x2F;jvisualVM&#x2F; Jprofiler（最好用）</p>
</li>
</ol>
<p>jstat -gc 4655 500 : 每个 500 个毫秒打印 GC 的情况</p>
<p>如果面试官问你是怎么定位 OOM 问题的？如果你回答用图形界面（错误）</p>
<p>1：已经上线的系统不用图形界面用什么？（cmdline arthas）</p>
<p>2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察）</p>
<ol start="10">
<li><p>jmap - histo 4655 | head -20，查找有多少对象产生</p>
</li>
<li><p>jmap -dump:format&#x3D;b,file&#x3D;xxx pid ：</p>
</li>
</ol>
<p>线上系统，内存特别大，jmap 执行期间会对进程产生很大影响，甚至卡顿（电商不适合）</p>
<p>1：设定了参数 HeapDump，OOM 的时候会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警）</p>
<p>2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响</p>
<p>3：在线定位(一般小点儿公司用不到)</p>
<p>4：在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）</p>
<ol start="12">
<li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01</p>
</li>
<li><p>使用 MAT &#x2F; jhat &#x2F;jvisualvm 进行 dump 文件分析</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html">https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html</a></p>
<p>jhat -J-mx512M xxx.dump</p>
<p><a target="_blank" rel="noopener" href="http://192.168.17.11:7000/">http://192.168.17.11:7000</a></p>
<p>拉到最后：找到对应链接</p>
<p>可以使用 OQL 查找特定问题对象</p>
<ol start="14">
<li>找到代码的问题</li>
</ol>
<h4 id="jconsole-远程连接"><a href="#jconsole-远程连接" class="headerlink" title="jconsole 远程连接"></a>jconsole 远程连接</h4><ol>
<li>程序启动加入参数：</li>
</ol>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">如果遭遇 Local host name unknown：XXX的错误，修改/etc/hosts文件，把XXX加入进去</span><br><span class="line"></span><br><span class="line">&gt; ```java</span><br><span class="line">192.168.17.11 basic localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关闭 linux 防火墙（实战中应该打开对应端口）</li>
</ol>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off #永久关闭</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">windows上打开 jconsole远程连接 192.168.17.11:11111</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### jvisualvm远程连接</span><br><span class="line"></span><br><span class="line">[https://www.cnblogs.com/liugh/p/7620336.html](https://www.cnblogs.com/liugh/p/7620336.html) （简单做法）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### jprofiler (收费)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### arthas在线排查工具</span><br><span class="line"></span><br><span class="line">- 为什么需要在线排查？</span><br><span class="line"></span><br><span class="line">在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。</span><br><span class="line">- jvm观察jvm信息</span><br><span class="line">- thread定位线程问题</span><br><span class="line">- dashboard 观察系统情况</span><br><span class="line">- heapdump + jhat分析</span><br><span class="line">- jad反编译</span><br><span class="line"></span><br><span class="line">动态代理生成类的问题定位</span><br><span class="line"></span><br><span class="line">第三方的类（观察代码）</span><br><span class="line"></span><br><span class="line">版本问题（确定自己最新提交的版本是不是被使用）</span><br><span class="line">- redefine 热替换</span><br><span class="line"></span><br><span class="line">目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性</span><br><span class="line"></span><br><span class="line">m() -&gt; mm()</span><br><span class="line">- sc  - search class</span><br><span class="line">- watch  - watch method</span><br><span class="line">- 没有包含的功能：jmap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### GC算法的基础概念</span><br><span class="line"></span><br><span class="line">- Card Table</span><br><span class="line"></span><br><span class="line">由于做YGC时，需要扫描整个OLD区，效率非常低，所以JVM设计了CardTable， 如果一个OLD区CardTable中有对象指向Y区，就将它设为Dirty，下次扫描时，只需要扫描Dirty Card</span><br><span class="line"></span><br><span class="line">在结构上，Card Table用BitMap来实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### CMS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### CMS的问题</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line">Memory Fragmentation</span><br><span class="line">&gt; -XX:+UseCMSCompactAtFullCollection</span><br><span class="line"></span><br><span class="line">-XX:CMSFullGCsBeforeCompaction 默认为0 指的是经过多少次FGC才进行压缩</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">Floating Garbage</span><br><span class="line">&gt; Concurrent Mode Failure</span><br><span class="line"></span><br><span class="line">产生：if the concurrent collector is unable to finish reclaiming the unreachable objects before the tenured generation fills up, or if an allocation cannot be satisfiedwith the available free space blocks in the tenured generation, then theapplication is paused and the collection is completed with all the applicationthreads stopped</span><br><span class="line"></span><br><span class="line">&gt; 解决方案：降低触发CMS的阈值</span><br><span class="line"></span><br><span class="line">&gt; PromotionFailed</span><br><span class="line"></span><br><span class="line">&gt; 解决方案类似，保持老年代有足够的空间</span><br><span class="line"></span><br><span class="line">&gt; –XX:CMSInitiatingOccupancyFraction 92% 可以降低这个值，让CMS保持老年代足够的空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### CMS日志分析</span><br><span class="line"></span><br><span class="line">执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [ParNew: 6144K-&gt;640K(6144K), 0.0265885 secs] 6585K-&gt;2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</span><br><span class="line"></span><br><span class="line">&gt; ParNew：年轻代收集器</span><br><span class="line"></span><br><span class="line">&gt; 6144-&gt;640：收集前后的对比</span><br><span class="line"></span><br><span class="line">&gt; （6144）：整个年轻代容量</span><br><span class="line"></span><br><span class="line">&gt; 6585 -&gt; 2770：整个堆的情况</span><br><span class="line"></span><br><span class="line">&gt; （19840）：整个堆大小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">[GC (CMS Initial Mark) [1 CMS-initial-mark: 8511K(13696K)] 9866K(19840K), 0.0040321 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br><span class="line">	//8511 (13696) : 老年代使用（最大）</span><br><span class="line">	//9866 (19840) : 整个堆使用（最大）</span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: 0.018/0.018 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</span><br><span class="line">	//这里的时间意义不大，因为是并发执行</span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">	//标记Card为Dirty，也称为Card Marking</span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 1597 K (6144 K)][Rescan (parallel) , 0.0008396 secs][weak refs processing, 0.0000138 secs][class unloading, 0.0005404 secs][scrub symbol table, 0.0006169 secs][scrub string table, 0.0004903 secs][1 CMS-remark: 8511K(13696K)] 10108K(19840K), 0.0039567 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">	//STW阶段，YG occupancy:年轻代占用及容量</span><br><span class="line">	//[Rescan (parallel)：STW下的存活对象标记</span><br><span class="line">	//weak refs processing: 弱引用处理</span><br><span class="line">	//class unloading: 卸载用不到的class</span><br><span class="line">	//scrub symbol(string) table:</span><br><span class="line">		//cleaning up symbol and string tables which hold class-level metadata and</span><br><span class="line">		//internalized string respectively</span><br><span class="line">	//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span><br><span class="line">	//10108K(19840K): 阶段过后的堆占用及容量</span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: 0.005/0.005 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br><span class="line">	//标记已经完成，进行并发清理</span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">	//重置内部结构，为下次GC做准备</span><br></pre></td></tr></table></figure>

<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ol>
<li>▪<a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">https://www.oracle.com/technical-resources/articles/java/g1gc.html</a></li>
</ol>
<h4 id="G1-日志详解"><a href="#G1-日志详解" class="headerlink" title="G1 日志详解"></a>G1 日志详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="title function_">pause</span> <span class="params">(G1 Evacuation Pause)</span> (young) (initial-mark), <span class="number">0.0015790</span> secs]</span><br><span class="line"><span class="comment">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象</span></span><br><span class="line"><span class="comment">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span><br><span class="line">   [Parallel Time: <span class="number">1.5</span> ms, GC Workers: <span class="number">1</span>] <span class="comment">//一个GC线程</span></span><br><span class="line">      [GC Worker <span class="title function_">Start</span> <span class="params">(ms)</span>:  <span class="number">92635.7</span>]</span><br><span class="line">      [Ext Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">1.1</span>]</span><br><span class="line">      [Update <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">         [Processed Buffers:  <span class="number">1</span>]</span><br><span class="line">      [Scan <span class="title function_">RS</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Code Root <span class="title function_">Scanning</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="title function_">Copy</span> <span class="params">(ms)</span>:  <span class="number">0.1</span>]</span><br><span class="line">      [Termination (ms):  <span class="number">0.0</span>]</span><br><span class="line">         [Termination Attempts:  <span class="number">1</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Other</span> <span class="params">(ms)</span>:  <span class="number">0.0</span>]</span><br><span class="line">      [GC Worker <span class="title function_">Total</span> <span class="params">(ms)</span>:  <span class="number">1.2</span>]</span><br><span class="line">      [GC Worker <span class="title function_">End</span> <span class="params">(ms)</span>:  <span class="number">92636.9</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.0</span> ms]</span><br><span class="line">   [Other: <span class="number">0.1</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Proc: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.0</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [Free CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)]</span><br><span class="line"> [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"><span class="comment">//以下是混合回收其他阶段</span></span><br><span class="line">[GC concurrent-root-region-scan-start]</span><br><span class="line">[GC concurrent-root-region-scan-end, <span class="number">0.0000078</span> secs]</span><br><span class="line">[GC concurrent-mark-start]</span><br><span class="line"><span class="comment">//无法evacuation，进行FGC</span></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span>  18M-&gt;18M(20M), <span class="number">0.0719656</span> secs]</span><br><span class="line">   [Eden: <span class="number">0.</span>0B(<span class="number">1024.</span>0K)-&gt;<span class="number">0.</span>0B(<span class="number">1024.</span>0K) Survivors: <span class="number">0.</span>0B-&gt;<span class="number">0.</span>0B Heap: <span class="number">18.</span>8M(<span class="number">20.</span>0M)-&gt;<span class="number">18.</span>8M(<span class="number">20.</span>0M)], [Metaspace: <span class="number">38</span></span><br><span class="line">76K-&gt;3876K(1056768K)] [Times: user=<span class="number">0.07</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></table></figure>

<h3 id="案例汇总"><a href="#案例汇总" class="headerlink" title="案例汇总"></a>案例汇总</h3><p>OOM 产生的原因多种多样，有些程序未必产生 OOM，不断 FGC(CPU 飙高，但内存回收特别少) （上面案例）</p>
<ol>
<li><p>硬件升级系统反而卡顿的问题（见上）</p>
</li>
<li><p>线程池不当运用产生 OOM 问题（见上）</p>
</li>
</ol>
<p>不断的往 List 里加对象（实在太 LOW）</p>
<ol start="3">
<li>smile jira 问题</li>
</ol>
<p>实际系统不断重启</p>
<p>解决问题 加内存 + 更换垃圾回收器 G1</p>
<p>真正问题在哪儿？不知道</p>
<ol start="4">
<li><p>tomcat http-header-size 过大问题（Hector）</p>
</li>
<li><p>lambda 表达式导致方法区溢出问题(MethodArea &#x2F; Perm Metaspace)</p>
</li>
</ol>
<p>LambdaGC.java     -XX:MaxMetaspaceSize&#x3D;9M -XX:+PrintGCDetails</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files\Java\jdk1.8.0_181\bin\java.exe&quot;</span> -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails <span class="string">&quot;-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\lib\idea_rt.jar=49316:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\bin&quot;</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath <span class="string">&quot;C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;C:\work\ijprojects\JVM\out\production\JVM;C:\work\ijprojects\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar&quot;</span> com.mashibing.jvm.gc.LambdaGC</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 11341K-&gt;1880K(38400K)] 11341K-&gt;1888K(125952K), <span class="number">0.0022190</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 1880K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;1777K(35328K)] 1888K-&gt;1777K(73728K), [Metaspace: 8164K-&gt;8164K(1056768K)], <span class="number">0.0100681</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line">[GC (Last ditch collection) [PSYoungGen: 0K-&gt;0K(38400K)] 1777K-&gt;1777K(73728K), <span class="number">0.0005698</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Last ditch collection)</span> [PSYoungGen: 0K-&gt;0K(38400K)] [ParOldGen: 1777K-&gt;1629K(67584K)] 1777K-&gt;1629K(105984K), [Metaspace: 8164K-&gt;8156K(1056768K)], <span class="number">0.0124299</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:<span class="number">388</span>)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:<span class="number">411</span>)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Compressed <span class="keyword">class</span> <span class="title class_">space</span></span><br><span class="line">	at sun.misc.Unsafe.defineClass(Native Method)</span><br><span class="line">	at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:<span class="number">63</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">399</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator$<span class="number">1.</span>run(MethodAccessorGenerator.java:<span class="number">394</span>)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:<span class="number">393</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(MethodAccessorGenerator.java:<span class="number">112</span>)</span><br><span class="line">	at sun.reflect.ReflectionFactory.generateConstructor(ReflectionFactory.java:<span class="number">398</span>)</span><br><span class="line">	at sun.reflect.ReflectionFactory.newConstructorForSerialization(ReflectionFactory.java:<span class="number">360</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.getSerializableConstructor(ObjectStreamClass.java:<span class="number">1574</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.access$<span class="number">1500</span>(ObjectStreamClass.java:<span class="number">79</span>)</span><br><span class="line">	at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">519</span>)</span><br><span class="line">	at java.io.ObjectStreamClass$<span class="number">3.</span>run(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:<span class="number">391</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1134</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:<span class="number">1548</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:<span class="number">1509</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:<span class="number">1432</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1178</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeJRMPStub(RMIConnectorServer.java:<span class="number">727</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeStub(RMIConnectorServer.java:<span class="number">719</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeStubInAddress(RMIConnectorServer.java:<span class="number">690</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.start(RMIConnectorServer.java:<span class="number">439</span>)</span><br><span class="line">	at sun.management.jmxremote.ConnectorBootstrap.startLocalConnectorServer(ConnectorBootstrap.java:<span class="number">550</span>)</span><br><span class="line">	at sun.management.Agent.startLocalManagementAgent(Agent.java:<span class="number">137</span>)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>直接内存溢出问题（少见）</li>
</ol>
<p>《深入理解 Java 虚拟机》P59，使用 Unsafe 分配直接内存，或者使用 NIO 的问题</p>
<ol start="7">
<li>栈溢出问题</li>
</ol>
<p>-Xss 设定太小</p>
<ol start="8">
<li>比较一下这两段程序的异同，分析哪一个是更优的写法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">    o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">//业务处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>重写 finalize 引发频繁 GC</li>
</ol>
<p>小米云，HBase 同步系统，系统通过 nginx 访问超时报警，最后排查，C 程序员重写 finalize 引发频繁 GC 问题</p>
<p>为什么 C 程序员会重写 finalize？（new delete）</p>
<p>finalize 耗时比较长（200ms）</p>
<ol start="10">
<li>如果有一个系统，内存一直消耗不超过 10%，但是观察 GC 日志，发现 FGC 总是频繁产生，会是什么引起的？</li>
</ol>
<p>System.gc() (这个比较 Low)</p>
<ol start="11">
<li><p>Distuptor 有个可以设置链的长度，如果过大，然后对象大，消费完不主动释放，会溢出 (来自 死物风情)</p>
</li>
<li><p>用 jvm 都会溢出，mycat 用崩过，1.6.5 某个临时版本解析 sql 子查询算法有问题，9 个 exists 的联合 sql 就导致生成几百万的对象（来自 死物风情）</p>
</li>
<li><p>new 大量线程，会产生 native thread OOM，（low）应该用线程池，</p>
</li>
</ol>
<p>解决方案：减少堆空间（太 TMlow 了）,预留更多内存产生 native thread</p>
<p>JVM 内存占物理内存比例 50% - 80%</p>
<ol start="14">
<li><p>近期学生案例 SQLLite 的类库，批处理的时候会把所有的结果加载内存，有的人一下子更新几十万条数据，结果就产生了内存溢出，定位上用的是排除法，去掉这个模块就没问题，加上该模块就会出问题</p>
</li>
<li><p>java 在线解压以及压缩文件造成的内存溢出</p>
</li>
<li><p>java 使用 opencv 造成的卡顿与缓慢</p>
</li>
<li><p>最容易引起崩溃的报表系统</p>
</li>
<li><p>分库分表所引起的系统崩溃</p>
</li>
</ol>
<h3 id="GC-常用参数"><a href="#GC-常用参数" class="headerlink" title="GC 常用参数"></a>GC 常用参数</h3><ul>
<li>-Xmn -Xms -Xmx -Xss</li>
</ul>
<p>年轻代 最小堆 最大堆 栈空间</p>
<ul>
<li>-XX:+UseTLAB</li>
</ul>
<p>使用 TLAB，默认打开</p>
<ul>
<li>-XX:+PrintTLAB</li>
</ul>
<p>打印 TLAB 的使用情况</p>
<ul>
<li>-XX:TLABSize</li>
</ul>
<p>设置 TLAB 大小</p>
<ul>
<li>-XX:+DisableExplictGC</li>
</ul>
<p>System.gc()不管用 ，FGC</p>
<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintHeapAtGC</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-XX:+PrintGCApplicationConcurrentTime (低)</li>
</ul>
<p>打印应用程序时间</p>
<ul>
<li>-XX:+PrintGCApplicationStoppedTime （低）</li>
</ul>
<p>打印暂停时长</p>
<ul>
<li>-XX:+PrintReferenceGC （重要性低）</li>
</ul>
<p>记录回收了多少种不同引用类型的引用</p>
<ul>
<li>-verbose:class</li>
</ul>
<p>类加载详细过程</p>
<ul>
<li>-XX:+PrintVMOptions</li>
<li>-XX:+PrintFlagsFinal  -XX:+PrintFlagsInitial</li>
</ul>
<p>必须会用</p>
<ul>
<li>-Xloggc:opt&#x2F;log&#x2F;gc.log</li>
<li>-XX:MaxTenuringThreshold</li>
</ul>
<p>升代年龄，最大值 15</p>
<ul>
<li>锁自旋次数 -XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold 逃逸分析 标量替换 …</li>
</ul>
<p>这些不建议设置</p>
<h3 id="Parallel-常用参数"><a href="#Parallel-常用参数" class="headerlink" title="Parallel 常用参数"></a>Parallel 常用参数</h3><ul>
<li>-XX:SurvivorRatio</li>
<li>-XX:PreTenureSizeThreshold</li>
</ul>
<p>大对象到底多大</p>
<ul>
<li>-XX:MaxTenuringThreshold</li>
<li>-XX:+ParallelGCThreads</li>
</ul>
<p>并行收集器的线程数，同样适用于 CMS，一般设为和 CPU 核数相同</p>
<ul>
<li>-XX:+UseAdaptiveSizePolicy</li>
</ul>
<p>自动选择各区大小比例</p>
<h3 id="CMS-常用参数"><a href="#CMS-常用参数" class="headerlink" title="CMS 常用参数"></a>CMS 常用参数</h3><ul>
<li>-XX:+UseConcMarkSweepGC</li>
<li>-XX:ParallelCMSThreads</li>
</ul>
<p>CMS 线程数量</p>
<ul>
<li>-XX:CMSInitiatingOccupancyFraction</li>
</ul>
<p>使用多少比例的老年代后开始 CMS 收集，默认是 68%(近似值)，如果频繁发生 SerialOld 卡顿，应该调小，（频繁 CMS 回收）</p>
<ul>
<li>-XX:+UseCMSCompactAtFullCollection</li>
</ul>
<p>在 FGC 时进行压缩</p>
<ul>
<li>-XX:CMSFullGCsBeforeCompaction</li>
</ul>
<p>多少次 FGC 之后进行压缩</p>
<ul>
<li>-XX:+CMSClassUnloadingEnabled</li>
<li>-XX:CMSInitiatingPermOccupancyFraction</li>
</ul>
<p>达到什么比例时进行 Perm 回收</p>
<ul>
<li>GCTimeRatio</li>
</ul>
<p>设置 GC 时间占用程序运行时间的百分比</p>
<ul>
<li>-XX:MaxGCPauseMillis</li>
</ul>
<p>停顿时间，是一个建议时间，GC 会尝试用各种手段达到这个时间，比如减小年轻代</p>
<h3 id="G1-常用参数"><a href="#G1-常用参数" class="headerlink" title="G1 常用参数"></a>G1 常用参数</h3><ul>
<li>-XX:+UseG1GC</li>
<li>-XX:MaxGCPauseMillis</li>
</ul>
<p>建议值，G1 会尝试调整 Young 区的块数来达到这个值</p>
<ul>
<li>-XX:GCPauseIntervalMillis</li>
</ul>
<p>？GC 的间隔时间</p>
<ul>
<li>-XX:+G1HeapRegionSize</li>
</ul>
<p>分区大小，建议逐渐增大该值，1 2 4 8 16 32。</p>
<p>随着 size 增加，垃圾的存活时间更长，GC 间隔更长，但每次 GC 的时间也会更长</p>
<p>ZGC 做了改进（动态区块大小）</p>
<ul>
<li>G1NewSizePercent</li>
</ul>
<p>新生代最小比例，默认为 5%</p>
<ul>
<li>G1MaxNewSizePercent</li>
</ul>
<p>新生代最大比例，默认为 60%</p>
<ul>
<li>GCTimeRatio</li>
</ul>
<p>GC 时间建议比例，G1 会根据这个值调整堆空间</p>
<ul>
<li>ConcGCThreads</li>
</ul>
<p>线程数量</p>
<ul>
<li>InitiatingHeapOccupancyPercent</li>
</ul>
<p>启动 G1 的堆空间占用比例</p>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><ol>
<li>-XX:MaxTenuringThreshold 控制的是什么？</li>
</ol>
<p>A: 对象升入老年代的年龄</p>
<p>B: 老年代触发 FGC 时的内存垃圾比例</p>
<ol start="2">
<li>生产环境中，倾向于将最大堆内存和最小堆内存设置为：（为什么？）</li>
</ol>
<p>A: 相同 B：不同</p>
<ol start="3">
<li>JDK1.8 默认的垃圾回收器是：</li>
</ol>
<p>A: ParNew + CMS</p>
<p>B: G1</p>
<p>C: PS + ParallelOld</p>
<p>D: 以上都不是</p>
<ol start="4">
<li><p>什么是响应时间优先？</p>
</li>
<li><p>什么是吞吐量优先？</p>
</li>
<li><p>ParNew 和 PS 的区别是什么？</p>
</li>
<li><p>ParNew 和 ParallelOld 的区别是什么？（年代不同，算法不同）</p>
</li>
<li><p>长时间计算的场景应该选择：A：停顿时间 B: 吞吐量</p>
</li>
<li><p>大规模电商网站应该选择：A：停顿时间 B: 吞吐量</p>
</li>
<li><p>HotSpot 的垃圾收集器最常用有哪些？</p>
</li>
<li><p>常见的 HotSpot 垃圾收集器组合有哪些？</p>
</li>
<li><p>JDK1.7 1.8 1.9 的默认垃圾回收器是什么？如何查看？</p>
</li>
<li><p>所谓调优，到底是在调什么？</p>
</li>
<li><p>如果采用 PS + ParrallelOld 组合，怎么做才能让系统基本不产生 FGC</p>
</li>
<li><p>如果采用 ParNew + CMS 组合，怎样做才能够让系统基本不产生 FGC</p>
</li>
</ol>
<p>1.加大 JVM 内存</p>
<p>2.加大 Young 的比例</p>
<p>3.提高 Y-O 的年龄</p>
<p>4.提高 S 区比例</p>
<p>5.避免代码内存泄漏</p>
<ol start="16">
<li><p>G1 是否分代？G1 垃圾回收器会产生 FGC 吗？</p>
</li>
<li><p>如果 G1 产生 FGC，你应该做什么？</p>
</li>
<li><p>扩内存</p>
</li>
<li><p>提高 CPU 性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大）</p>
</li>
<li><p>降低 MixedGC 触发的阈值，让 MixedGC 提早发生（默认是 45%）</p>
</li>
<li><p>问：生产环境中能够随随便便的 dump 吗？</p>
</li>
</ol>
<p>小堆影响不大，大堆会有服务暂停或卡顿（加 live 可以缓解），dump 前会有 FGC</p>
<ol start="19">
<li>问：常见的 OOM 问题有哪些？</li>
</ol>
<p>栈 堆 MethodArea 直接内存</p>
<ol start="20">
<li><p><strong>如果 JVM 进程静悄悄退出怎么办？</strong></p>
</li>
<li><p>JVM 自身 OOM 导致</p>
<ol>
<li>heap dump on oom，这种最容易解决</li>
</ol>
</li>
<li><p>JVM 自身故障</p>
<ol>
<li>-XX:ErrorFile&#x3D;&#x2F;var&#x2F;log&#x2F;hs_err_pid.log 超级复杂的文件 包括：crash 线程信息 safepoint 信息 锁信息 native code cache , 编译事件, gc 相关记录 jvm 内存映射 等等</li>
</ol>
</li>
<li><p>被 Linux OOM killer 杀死</p>
<ol>
<li>日志位于&#x2F;var&#x2F;log&#x2F;messages</li>
<li>egrep -i ‘killed process’ &#x2F;var&#x2F;log&#x2F;messages</li>
</ol>
</li>
<li><p>硬件或内核问题</p>
<ol>
<li>dmesg | grep java</li>
</ol>
</li>
<li><p><strong>找我！</strong></p>
</li>
<li><p><strong>如何排查直接内存</strong>？</p>
</li>
<li><p>NMT 打开 – -XX:NativeMemoryTracking&#x3D;detail</p>
</li>
<li><p>perf 工具</p>
</li>
<li><p>gperftools</p>
</li>
<li><p>有哪些常用的日志分析工具？</p>
</li>
<li><p>gceasy</p>
</li>
<li><p>CPU 暴增如何排查？</p>
</li>
<li><p>top -Hp  jstack</p>
</li>
<li><p>arthas - dashboard thread thread XXXX</p>
</li>
<li><p>两种情况：1：业务线程 2：GC 线程 - GC 日志</p>
</li>
<li><p>死锁如何排查？</p>
</li>
<li><p>jstack 观察线程情况</p>
</li>
<li><p>arthas -  thread -b</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://blogs.oracle.com/jonthecollector/our-collectors">https://blogs.oracle.com/</a><a target="_blank" rel="noopener" href="https://blogs.oracle.com/jonthecollector/our-collectors">jonthecollector</a><a target="_blank" rel="noopener" href="https://blogs.oracle.com/jonthecollector/our-collectors">&#x2F;our-collectors</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp">http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</a></p>
</li>
<li><p>JVM 调优参考文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184">https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nxlhero/p/11660854.html">https://www.cnblogs.com/nxlhero/p/11660854.html</a> 在线排查工具</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/507f7e0cc3a3">https://www.jianshu.com/p/507f7e0cc3a3</a> arthas 常用命令</p>
</li>
<li><p>Arthas 手册：</p>
<ol>
<li>启动 arthas java -jar arthas-boot.jar</li>
<li>绑定 java 进程</li>
<li>dashboard 命令观察系统整体情况</li>
<li>help 查看帮助</li>
<li>help xx 查看具体命令帮助</li>
</ol>
</li>
<li><p>jmap 命令参考： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/507f7e0cc3a3">https://www.jianshu.com/p/507f7e0cc3a3</a></p>
<ol>
<li>jmap -heap pid</li>
<li>jmap -histo pid</li>
<li>jmap -clstats pid</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenssy/article/details/78271744">https://blog.csdn.net/chenssy/article/details/78271744</a> 分析 hotspot error file</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/12/04/yuque/GC%E5%92%8CGC%20Tuning/" data-id="cl3zp2b5p000f1w7shhi5b6fo" data-title="GC和GC Tuning" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/Redis集群" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/21/yuque/Redis%E9%9B%86%E7%BE%A4/" class="article-date">
  <time class="dt-published" datetime="2020-11-21T03:11:50.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/21/yuque/Redis%E9%9B%86%E7%BE%A4/">Redis集群</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>技术点:gossip 通信协议,hash solt 算法</p>
<h2 id="一致性-Hash"><a href="#一致性-Hash" class="headerlink" title="一致性 Hash"></a>一致性 Hash</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/129049724">一致性 hash 算法</a></p>
<blockquote>
<p>一致性 hash 需要再整理一篇文章</p>
</blockquote>
<h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><ol>
<li>使用 zookeeper 进行中心化的数据管理，所有元数据存放在 zookeeper 中<ol>
<li>时效性好</li>
<li>健壮性降低，当 zookeeper 挂掉后集群全部失效</li>
</ol>
</li>
<li>使用 master 进行无中心化的数据管理，每个 master 都存储一份元数据<ol>
<li>元数据更新有延迟</li>
<li>提高健壮性</li>
</ol>
</li>
</ol>
<h2 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h2><p>1、基础通信原理<br>（1）redis cluster 节点间采取 gossip 协议进行通信<br>跟集中式不同，不是将集群元数据（节点信息，故障，等等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的<br>（2）10000 端口<br>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口<br>每隔节点每隔一段时间都会往另外几个节点发送 ping 消息，同时其他几点接收到 ping 之后返回 pong<br>（3）交换的信息<br>故障信息，节点的增加和移除，hash slot 信息，等等<br>2、gossip 协议<br>gossip 协议包含多种消息，包括 ping，pong，meet，fail，等等<br>meet: 某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信<br>redis-trib.rb add-node<br>其实内部就是发送了一个 gossip meet 消息，给新加入的节点，通知那个节点去加入我们的集群<br>ping: 每个节点都会频繁给其他节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据<br>每个节点每秒都会频繁发送 ping 给其他的集群，ping，频繁的互相之间交换数据，互相进行元数据的更新<br>pong: 返回 ping 和 meet，包含自己的状态和其他信息，也可以用于信息广播和更新<br>fail: 某个节点判断另一个节点 fail 之后，就发送 fail 给其他节点，通知其他节点，指定的节点宕机了<br>3、ping 消息深入<br>ping 很频繁，而且要携带一些元数据，所以可能会加重网络负担<br>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其他节点<br>当然如果发现某个节点通信延时达到了 cluster_node_timeout &#x2F; 2，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了<br>比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题<br>所以 cluster_node_timeout 可以调节，如果调节比较大，那么会降低发送的频率<br>每次 ping，一个是带上自己节点的信息，还有就是带上 1&#x2F;10 其他节点的信息，发送出去，进行数据交换<br>至少包含 3 个其他节点的信息，最多包含总节点-2 个其他节点的信息</p>
<hr>
<h2 id="面向集群的-jedis-内部实现原理"><a href="#面向集群的-jedis-内部实现原理" class="headerlink" title="面向集群的 jedis 内部实现原理"></a>面向集群的 jedis 内部实现原理</h2><p>开发，jedis，redis 的 java client 客户端，redis cluster，jedis cluster api<br>jedis cluster api 与 redis cluster 集群交互的一些基本原理<br>1、基于重定向的客户端<br>redis-cli -c，自动重定向<br>（1）请求重定向<br>客户端可能会挑选任意一个 redis 实例去发送命令，每个 redis 实例接收到命令，都会计算 key 对应的 hash slot<br>如果在本地就在本地处理，否则返回 moved 给客户端，让客户端进行重定向<br>cluster keyslot mykey，可以查看一个 key 对应的 hash slot 是什么<br>用 redis-cli 的时候，可以加入-c 参数，支持自动的请求重定向，redis-cli 接收到 moved 之后，会自动重定向到对应的节点执行命令<br>（2）计算 hash slot<br>计算 hash slot 的算法，就是根据 key 计算 CRC16 值，然后对 16384 取模，拿到对应的 hash slot<br>用 hash tag 可以手动指定 key 对应的 slot，同一个 hash tag 下的 key，都会在一个 hash slot 中，比如 set mykey1:{100}和 set mykey2:{100}<br>（3）hash slot 查找<br>节点间通过 gossip 协议进行数据交换，就知道每个 hash slot 在哪个节点上<br>（4）hash slot 计算<br>redis cluster 中有固定的 16384 个 hash slot，这 16384 个 slot 会均匀分配到各个 master 上面，通过这种模式，想要判断一个 key，value 想要存到那一台主机上，只需要算出这个 key 对应的 slot 是哪一个，集群模式 redis 中的 master 存有自己所有的 slot 信息，除此还会保存其他 master 和其他 master 所有的 slot 信息<br>2、smart jedis<br>（1）什么是 smart jedis<br>基于重定向的客户端，很消耗网络 IO，因为大部分情况下，可能都会出现一次请求重定向，才能找到正确的节点<br>所以大部分的客户端，比如 java redis 客户端，就是 jedis，都是 smart 的<br>本地维护一份 hashslot -&gt; node 的映射表，缓存，大部分情况下，直接走本地缓存就可以找到 hashslot -&gt; node，不需要通过节点进行 moved 重定向<br>（2）JedisCluster 的工作原理<br>在 JedisCluster 初始化的时候，就会随机选择一个 node，初始化 hashslot -&gt; node 映射表，同时为每个节点创建一个 JedisPool 连接池<br>每次基于 JedisCluster 执行操作，首先 JedisCluster 都会在本地计算 key 的 hashslot，然后在本地映射表找到对应的节点<br>如果那个 node 正好还是持有那个 hashslot，那么就 ok; 如果说进行了 reshard 这样的操作，可能 hashslot 已经不在那个 node 上了，就会返回 moved<br>如果 JedisCluter API 发现对应的节点返回 moved，那么利用该节点的元数据，更新本地的 hashslot -&gt; node 映射表缓存<br>重复上面几个步骤，直到找到对应的节点，如果重试超过 5 次，那么就报错，JedisClusterMaxRedirectionException<br>jedis 老版本，可能会出现在集群某个节点故障还没完成自动切换恢复时，频繁更新 hash slot，频繁 ping 节点检查活跃，导致大量网络 IO 开销<br>jedis 最新版本，对于这些过度的 hash slot 更新和 ping，都进行了优化，避免了类似问题<br>（3）hashslot 迁移和 ask 重定向<br>如果 hash slot 正在迁移，那么会返回 ask 重定向给 jedis<br>jedis 接收到 ask 重定向之后，会重新定位到目标节点去执行，但是因为 ask 发生在 hash slot 迁移过程中，所以 JedisCluster API 收到 ask 是不会更新 hashslot 本地缓存<br>已经可以确定说，hashslot 已经迁移完了，moved 是会更新本地 hashslot-&gt;node 映射表缓存的</p>
<hr>
<h2 id="高可用性与主备切换原理"><a href="#高可用性与主备切换原理" class="headerlink" title="高可用性与主备切换原理"></a>高可用性与主备切换原理</h2><p>redis cluster 的高可用的原理，几乎跟哨兵是类似的<br>1、判断节点宕机<br>如果一个节点认为另外一个节点宕机，那么就是 pfail，主观宕机<br>如果多个节点都认为另外一个节点宕机了，那么就是 fail，客观宕机，跟哨兵的原理几乎一样，sdown，odown<br>在 cluster-node-timeout 内，某个节点一直没有返回 pong，那么就被认为 pfail<br>如果一个节点认为某个节点 pfail 了，那么会在 gossip ping 消息中，ping 给其他节点，如果超过半数的节点都认为 pfail 了，那么就会变成 fail<br>2、从节点过滤<br>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node<br>检查每个 slave node 与 master node 断开连接的时间，如果超过了 cluster-node-timeout * cluster-slave-validity-factor，那么就没有资格切换成 master<br>这个也是跟哨兵是一样的，从节点超时过滤的步骤<br>3、从节点选举<br>哨兵：对所有从节点进行排序，slave priority，offset，run id<br>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举<br>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node（N&#x2F;2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master<br>从节点执行主备切换，从节点切换为主节点，整个流程跟哨兵相比，非常类似，所以说，redis cluster 功能强大，直接集成了 replication 和 sentinal 的功能<br>4、slave 冗余<br>如果一个 master 搭配一个 slave，这时可以给集群添加 slave 冗余，当其中一个 master 对应的冗余挂掉后，冗余的 slave 可以自动迁移到对应的 master 上去。</p>
<hr>
<h2 id="集群优化"><a href="#集群优化" class="headerlink" title="集群优化"></a>集群优化</h2><p>1、fork 耗时导致高并发请求延时<br>RDB 和 AOF 的时候，其实会有生成 RDB 快照，AOF rewrite，耗费磁盘 IO 的过程，主进程 fork 子进程<br>fork 的时候，子进程是需要拷贝父进程的空间内存页表的，也是会耗费一定的时间的<br>一般来说，如果父进程内存有 1 个 G 的数据，那么 fork 可能会耗费在 20ms 左右，如果是 10G~30G，那么就会耗费 20 _ 10，甚至 20 _ 30，也就是几百毫秒的时间<br>info stats 中的 latest_fork_usec，可以看到最近一次 fork 的时长<br>redis 单机 QPS 一般在几万，fork 可能一下子就会拖慢几万条操作的请求时长，从几毫秒变成 1 秒<br>优化思路<br>fork 耗时跟 redis 主进程的内存有关系，一般控制 redis 的内存在 10GB 以内，slave -&gt; master，全量复制<br>2、AOF 的阻塞问题<br>redis 将数据写入 AOF 缓冲区，单独开一个现场做 fsync 操作，每秒一次<br>但是 redis 主线程会检查两次 fsync 的时间，如果距离上次 fsync 时间超过了 2 秒，那么写请求就会阻塞<br>everysec，最多丢失 2 秒的数据<br>一旦 fsync 超过 2 秒的延时，整个 redis 就被拖慢<br>优化思路<br>优化硬盘写入速度，建议采用 SSD，不要用普通的机械硬盘，SSD，大幅度提升磁盘读写的速度<br>3、主从复制延迟问题<br>主从复制可能会超时严重，这个时候需要良好的监控和报警机制<br>在 info replication 中，可以看到 master 和 slave 复制的 offset，做一个差值就可以看到对应的延迟量<br>如果延迟过多，那么就进行报警<br>4、主从复制风暴问题<br>如果一下子让多个 slave 从 master 去执行全量复制，一份大的 rdb 同时发送到多个 slave，会导致网络带宽被严重占用<br>如果一个 master 真的要挂载多个 slave，那尽量用树状结构，不要用星型结构</p>
<hr>
<p>linux 系统配置相关的优化，redis 启动的时候会有相应的提示。<br>1、vm.overcommit_memory<br>0: 检查有没有足够内存，没有的话申请内存失败<br>1: 允许使用内存直到用完为止<br>2: 内存地址空间不能超过 swap + 50%<br>如果是 0 的话，可能导致类似 fork 等操作执行失败，申请不到足够的内存空间<br>2、swapiness<br>保证 redis 不会被系统主动杀掉<br>cat &#x2F;proc&#x2F;version，查看 linux 内核版本<br>如果 linux 内核版本&lt;3.5，那么 swapiness 设置为 0，这样系统宁愿 swap 也不会 oom killer（杀掉进程）<br>如果 linux 内核版本&gt;&#x3D;3.5，那么 swapiness 设置为 1，这样系统宁愿 swap 也不会 oom killer<br>3、设置最大打开文件句柄<br>ulimit -n 10032 10032<br>4、tcp backlog</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/11/21/yuque/Redis%E9%9B%86%E7%BE%A4/" data-id="cl3zp2b5w000w1w7s7pludibv" data-title="Redis集群" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/分布式锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/21/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2020-11-21T02:50:09.000Z" itemprop="datePublished">2020-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/21/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><ol>
<li>key 为资源最小锁定值，缩小互斥范围</li>
<li>value 为当前线程唯一 id，防止其他线程误删锁</li>
<li>使用 setnx 命令加锁，保证线程独占</li>
<li>设置锁失效时间，防止 down 机后锁无法释放</li>
</ol>
<h2 id="续锁"><a href="#续锁" class="headerlink" title="续锁"></a>续锁</h2><ol>
<li>加锁成功后启动看门狗线程</li>
<li>每隔 ExpiredTime&#x2F;3 时间，如果锁未释放则进行续约</li>
</ol>
<h2 id="删锁"><a href="#删锁" class="headerlink" title="删锁"></a>删锁</h2><ol>
<li>将删锁代码放在 finally 代码块内，防止程序异常导致无法删锁</li>
<li>删锁时判断 value 是否为当前线程 id，防止误删其他线程的锁</li>
</ol>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol>
<li>加锁、续锁、删锁都有多条 redis 命令，使用 lua 脚本保证执行的原子性</li>
<li>分布式锁并行化优化—-读写锁、分段锁</li>
<li>集群的情况下，锁有丢失风险，需要使用 RedLock</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/11/21/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" data-id="cl3zp2b63001b1w7s7kyzdvlo" data-title="分布式锁" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/31/yuque/%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2020-10-31T11:35:56.000Z" itemprop="datePublished">2020-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/31/yuque/%E6%A0%91/">树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="重要的三种树"><a href="#重要的三种树" class="headerlink" title="重要的三种树"></a>重要的三种树</h2><table>
<thead>
<tr>
<th></th>
<th>应用</th>
<th>重要特点</th>
</tr>
</thead>
<tbody><tr>
<td>B 树</td>
<td>文件系统、MongoDB</td>
<td>占用更小空间</td>
</tr>
<tr>
<td>数据量少的情况下查找更快，数据量多的情况下树的高度不可控</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B+树</td>
<td>MySQL、磁盘</td>
<td>树的高度可控</td>
</tr>
</tbody></table>
<p>查询效率更稳定<br>数据在叶子节点顺序存放,连续的范围查询更快 |<br>| 红黑树 | HashMap | 解决平衡树维护麻烦的问题（三次旋转内解决不平衡）<br>时间复杂度 O(log n) |</p>
<h2 id="好文章"><a href="#好文章" class="headerlink" title="好文章"></a>好文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lovely_girl1126/article/details/106986209">B、B+、红黑树特点和区别</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/10/31/yuque/%E6%A0%91/" data-id="cl3zp2b6f001z1w7s0puef72r" data-title="树" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/接口幂等" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/18/yuque/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/" class="article-date">
  <time class="dt-published" datetime="2020-10-18T01:50:28.000Z" itemprop="datePublished">2020-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/18/yuque/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/">接口幂等</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="调用幂等性"><a href="#调用幂等性" class="headerlink" title="调用幂等性"></a>调用幂等性</h2><h4 id="数据库唯一索引"><a href="#数据库唯一索引" class="headerlink" title="数据库唯一索引"></a>数据库唯一索引</h4><p>将接口的唯一标时，如 orderId 作为数据库中唯一索引，使数据插入时失败，失败时不重复处理。</p>
<h4 id="缓存唯一标时"><a href="#缓存唯一标时" class="headerlink" title="缓存唯一标时"></a>缓存唯一标时</h4><p>通过缓存判断此订单是否已经处理，需要考虑缓存服务宕机时的处理。</p>
<ol>
<li>缓存需要持久化</li>
<li>缓存宕机时阻塞请求或者返回失败，等待缓存恢复后继续处理</li>
</ol>
<h2 id="调用顺序性"><a href="#调用顺序性" class="headerlink" title="调用顺序性"></a>调用顺序性</h2><h4 id="中间服务请求路由"><a href="#中间服务请求路由" class="headerlink" title="中间服务请求路由"></a>中间服务请求路由</h4><p>所有请求通过中间服务进行路由，将同一队列中的请求标识顺序并路由到同一台服务器，在服务内做缓存队列，然后顺序处理。</p>
<h4 id="分布式锁强一致"><a href="#分布式锁强一致" class="headerlink" title="分布式锁强一致"></a>分布式锁强一致</h4><p>同一队列中的请求通过拿锁保证顺序性，根据顺序标识，序号 3 在 2 拿锁成功前会拿锁失败。拿锁成功后调用成功。为保证上层服务快速响应，可以添加消息中间件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/10/18/yuque/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/" data-id="cl3zp2b6d001u1w7sbjsg5w7d" data-title="接口幂等" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/JVM内存模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/08/yuque/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2020-09-08T07:10:49.000Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/08/yuque/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">JVM内存模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>原子性<ul>
<li>通过锁或者 CAS 无锁来保证</li>
</ul>
</li>
<li>可见性<ul>
<li>通过锁或者 volatile 来保证</li>
</ul>
</li>
<li>有序性<ul>
<li>as-if-serial 保证单线程内程序的执行结果不会变</li>
<li>hanppens-before 保证正确同步的多线程程序执行结果不会变<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li>
<li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li>
<li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li>
<li>start()规则：如果线程 A 执行操作 ThreadB.start()（启动线程 B），那么 A 线程的 ThreadB.start()操作 happens-before 于线程 B 中的任意操作。</li>
<li>join()规则：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。</li>
<li>程序中断规则：对线程 interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li>对象 finalize 规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的 finalize()方法的开始。</li>
</ul>
</li>
<li>都是在保证程序结果不变的情况下尽可能地提高程序效率</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/09/08/yuque/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-id="cl3zp2b5s000m1w7s4zso7uz0" data-title="JVM内存模型" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%80%E5%8E%86/" rel="tag">简历</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/%E7%AE%80%E5%8E%86/" style="font-size: 10px;">简历</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/">个人简历</a>
          </li>
        
          <li>
            <a href="/2022/06/01/yuque/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/">系统设计相关</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/">问题以及方案</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/">缓存和数据库双写不一致</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>