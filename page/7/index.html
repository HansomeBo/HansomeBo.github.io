<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>HandsomeBo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="HandsomeBo">
<meta property="og:url" content="http://handsomebo.com/page/7/index.html">
<meta property="og:site_name" content="HandsomeBo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HandsomeBo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HandsomeBo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://handsomebo.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-yuque/自定义注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/28/yuque/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2020-08-28T07:25:54.000Z" itemprop="datePublished">2020-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/28/yuque/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/">自定义注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/28/yuque/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" data-id="cl3zp2b6q002g1w7s89eq7c0i" data-title="自定义注解" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/ConcurrentHashMap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/24/yuque/ConcurrentHashMap/" class="article-date">
  <time class="dt-published" datetime="2020-08-24T06:31:32.000Z" itemprop="datePublished">2020-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/24/yuque/ConcurrentHashMap/">ConcurrentHashMap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h1><p>1.7 通过 Segement 可重入的分段锁<br>1.8 元素链表头节点 CAS 实现锁分离；volatile 修饰 table 和 sizeCtl 属性保证线程可见</p>
<h1 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h1><h2 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h2><p>默认为 0，用来控制 table 的初始化和扩容操作<br>-1  代表 table 正在初始化<br>-N  表示有 N-1 个线程正在进行扩容操作  <br>如果 table 未初始化，表示 table 需要初始化的大小。<br>如果 table 初始化完成，表示 table 的容量，默认是 table 大小的 0.75 倍</p>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><h2 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h2><p>1、通过 CPU 核心数和数组长度计算每个线程负责迁移的桶个数，最小为 16。线程数量如何确定？<br>2、初始化 nextTable，将原 table 容量增加一倍。<br>3、将原 table 链表或者红黑树中的元素分为高位链和低位链，然后将链表移动到 n+1 位置上去。<br>4、最后一个扩容线程会负责重新检查一遍数组查看是否有遗漏的桶</p>
<h2 id="扩容中并发读写的处理"><a href="#扩容中并发读写的处理" class="headerlink" title="扩容中并发读写的处理"></a>扩容中并发读写的处理</h2><p>1、对于 get 读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。如果当前链表已经迁移完成，那么头节点会被设置成 fwd 节点，此时 get 线程会帮助扩容。<br>2、对于 put&#x2F;remove 写操作，如果当前链表已经迁移完成，那么头节点会被设置成 fwd 节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。</p>
<h1 id="好文章"><a href="#好文章" class="headerlink" title="好文章"></a>好文章</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">ConcurrentHashMap1.8 - 扩容详解 CSDN</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6864211256631853070">ConcurrentHashMap 方法属性分析 掘金</a></p>
<h1 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h1><p>1、扩容过程中的线程数变更和线程分配的桶如何变更<br>2、高位链低位链的生成和迁移过程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/24/yuque/ConcurrentHashMap/" data-id="cl3zp2b5j00041w7se4nag85p" data-title="ConcurrentHashMap" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/Map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/Map/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T07:16:47.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/Map/">Map</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1982501/1608218511273-4ea426ee-5ad8-411b-b6b7-fcda5fb60c1f.jpeg"></p>
<h2 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h2><p>hash &#x3D; (h &#x3D; hashCode())^(h &gt;&gt;&gt; 16)<br>hash 值总共 32 位，让 hash 值的高 16 位和低 16 位进行异或，目的是让高位和低位都参与之后的“与运算”，这个“与运算”计算出此元素的索引。<br>hashCode()是一个 native 方法，而且返回值类型是整形；实际上，该 native 方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。</p>
<h2 id="寻址算法"><a href="#寻址算法" class="headerlink" title="寻址算法"></a>寻址算法</h2><p>index &#x3D; (n - 1) &amp; hash<br>在 n&#x3D; 2 的 n 次方的前提下，这个“与运算”和将 hash 值对 n 取模效果一样，但是执行效率高于取模。<br>因为数组长度 n 有限，只有 hash 的低 16 位会参与与运算，所以需要第一步让高 16 位也参与“与运算”</p>
<hr>
<h2 id="Map-为什么双倍扩容"><a href="#Map-为什么双倍扩容" class="headerlink" title="Map 为什么双倍扩容"></a>Map 为什么双倍扩容</h2><p>1、索引计算方式为 (n - 1) &amp; hash，当 n 为 2 的倍数时，索引会更加分散。<br>这里不使用数组长度取模的方式的原因<br>    (1) &amp; 操作效率更高<br>(2) 取模的方式数据冲突更高<br>2、数组扩容完，在对链表进行数据迁移时，不需要重新计算索引值。<br>新索引位置为 n+1，n 为原数组长度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/Map/" data-id="cl3zp2b5t000p1w7s0eqg4k2e" data-title="Map" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/动态代理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T06:58:23.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">动态代理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1982501/1598929838894-33edaa13-a2f2-4e11-b32f-77593b0558ce.png"></p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>利用拦截器(拦截器必须实现 InvocationHanlder) + 反射机制生成一个实现代理接口的匿名类。根据反射获取到的信息动态生成.java 文件，然后动态编译生成.class 文件。</p>
<h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p>利用 ASM 开源包，对代理对象类的 class 文件加载进来，通过修改字节码生成子类。</p>
<hr>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="JDK-动态代理和-CGLIB-字节码生成的区别"><a href="#JDK-动态代理和-CGLIB-字节码生成的区别" class="headerlink" title="JDK 动态代理和 CGLIB 字节码生成的区别"></a>JDK 动态代理和 CGLIB 字节码生成的区别</h2><ol>
<li>JDK 动态代理只能对实现了接口的类生成代理，而不能针对类。</li>
<li>CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。</li>
</ol>
<p>所以 CGLib 不能对声明为 final 的方法进行代理。</p>
<h2 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h2><ol>
<li>CGLib 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类，在 jdk6 之前比使用 Java 反射效率要高&#x2F;</li>
<li>在 jdk6、jdk7、jdk8 逐步对 JDK 动态代理优化之后，在调用次数较少的情况下，JDK 代理效率高于 CGLIB 代理效率。</li>
<li>优先 jdk 代理，每一次 jdk 版本升级，jdk 代理效率都得到提升，而 CGLIB 代理消息确有点跟不上步伐。</li>
</ol>
<h2 id="Spring-如何选择用-JDK-还是-CGLIB"><a href="#Spring-如何选择用-JDK-还是-CGLIB" class="headerlink" title="Spring 如何选择用 JDK 还是 CGLIB"></a>Spring 如何选择用 JDK 还是 CGLIB</h2><ol>
<li>当 Bean 实现接口时，Spring 就会用 JDK 的动态代理。</li>
<li>当 Bean 没有实现接口时，Spring 使用 CGlib 是实现。</li>
<li>可以强制使用 CGlib（在 spring 配置中加入&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&#x2F;&gt;）</li>
</ol>
<hr>
<h1 id="三连问"><a href="#三连问" class="headerlink" title="三连问"></a>三连问</h1><ol>
<li>JDK 动态代理有什么使用条件？</li>
</ol>
<p>JDK 动态代理只能对实现了接口的类进行代理</p>
<ol start="2">
<li>为什么 JDK 动态代理对象类必须要实现接口？</li>
</ol>
<p>因为这种方式生成的代理类继承了 Proxy 类，且 JAVA 无法多继承，只能通过实现接口的方式来代理。</p>
<ol start="3">
<li>为什么 JDK 动态代理生成的类继承 Proxy，导致代理对象必须要有接口。<ul>
<li>代理模式中的代理类只做转发处理，方法执行转发给原类，增强程序的执行转发给拦截器。</li>
<li>从效率上来看直接代理类比转发接口更消耗内存。</li>
<li>这也是为什么 JDK 动态代理需要传入被代理类的实例划对象，而不是直接传入被代理类 Class 对象。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" data-id="cl3zp2b64001d1w7s0f5c3vmu" data-title="动态代理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/集合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/%E9%9B%86%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T06:58:12.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/%E9%9B%86%E5%90%88/">集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th align="center"><a target="_blank" rel="noopener" href="https://www.yuque.com/hansomebo/uav9dd/xfgyi9">Map</a></th>
<th>集合</th>
<th>数据结构</th>
<th>线程安全</th>
<th>应用场景</th>
<th>顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td>HashMap</td>
<td>1.7 数组 + 链表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">1.8 数组 + 链表 + 红黑树</td>
<td>不安全</td>
<td></td>
<td>无序</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td><a target="_blank" rel="noopener" href="https://www.yuque.com/hansomebo/uav9dd/iiomcz">ConCurrentHashMap</a></td>
<td>同 HashMap</td>
<td>安全</td>
<td></td>
<td>无序</td>
</tr>
<tr>
<td align="center"></td>
<td>HashTable</td>
<td>同 HashMap</td>
<td>安全 sycronized</td>
<td>线程安全</td>
<td></td>
</tr>
<tr>
<td align="center">效率低</td>
<td>无序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td>LinkedHashMap</td>
<td>HashMap + 双向链表</td>
<td>不安全</td>
<td></td>
<td>基于插入顺序</td>
</tr>
<tr>
<td align="center">和访问顺序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td>TreeMap</td>
<td>红黑树</td>
<td>不安全</td>
<td></td>
<td>有序</td>
</tr>
</tbody></table>
<p>|</p>
<p>List | ArrayList | 数组 | 不安全 | 读多写少 | 无序 |<br>| | Vector | 数组 | 安全<br>sycronized | 线程安全<br>效率低 | 无序 |<br>| | LinkedList | 双向链表 | 不安全 | 读少写多 | 无序 |<br>| | CopyOnWriteList | 数组 | 安全 | 效率低<br>耗内存 | |<br>| Set | HashSet | HashMap | 不安全 | | 无序 |<br>| | TreeSet | 红黑树 | 不安全 | | 有序 |<br>| | LinkedHashSet | HashMap + 双向链表 | 不安全 | | 无序 |<br>| | CopyOnWriteArraySet | | 安全 | | |</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/%E9%9B%86%E5%90%88/" data-id="cl3zp2b6s002n1w7s2i9ud2uf" data-title="集合" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/CPU到100%分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/CPU0100%25%06%EF%BF%BD/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T06:56:37.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/CPU0100%25%06%EF%BF%BD/">CPU到100%分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>一定有某个线程 CPU 占用比较高<br>分业务线程和系统线程</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>top -c 显示进程列表，输入 P 根据 cpu 使用率排序，查看 cpu 占用比较高的进程</li>
<li>top -Hp 进程 pid ，输入 P 根据 cpu 使用率排序，查看 cpu 占用比较高的线程</li>
<li>printf “%x\n” 线程 pid ，将线程 pid 转换成 16 进制</li>
<li>jstack 进程 pid | grep ‘线程 pid’ 找到这个线程的堆栈信息，定位对应的代码</li>
</ol>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>arthas<br>jmap<br>jinfo<br>Java VisualVM<br>jconsole</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/CPU%E5%88%B0100%%E5%88%86%E6%9E%90/" data-id="cl3zp2b5k00061w7shnuvbu9f" data-title="CPU到100%分析" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/秒杀系统设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T06:56:30.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">秒杀系统设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="“秒杀”系统的技术挑战与架构优化"><a href="#“秒杀”系统的技术挑战与架构优化" class="headerlink" title="“秒杀”系统的技术挑战与架构优化"></a>“秒杀”系统的技术挑战与架构优化</h4><p>“秒杀”系统的建设需要整个系统从前到后全栈的协同配合，其中包含了基础技术部维护的多个服务，比如 CDN、高防 IP、容器平台、缓存、数据库、中间件、全链路压测、监控系统等，我们围绕这些基础服务讨论秒杀系统的技术挑战与架构优化。</p>
<ul>
<li><strong>前端与接入层：加速与限流</strong></li>
</ul>
<p>前端动静分离，把 90%的静态数据缓存在用户端或者 CDN 上，当真正秒杀时用户只需要点击特殊的按钮“刷新抢宝”即可，而不需要刷新整个页面，这样只向服务端请求很少的有效数据，而不需要重复请求大量静态数据。<br>网站负载均衡层或业务网关层需要能够对访问请求按用户粒度进行流量限制，以降低抢购脚本对系统带来的压力。<br>在安全方面，通过高防 CDN 或高防 IP，降低 DDOS 攻击的影响。<br>在业务方面，通过引入答题环节，将突然涌入的压力平滑到 3s 左右的时间段内。</p>
<ul>
<li><strong>业务层：隔离、限流与弹性伸缩</strong></li>
</ul>
<p>通过对后台系统的微服务化改造和数据库层面的拆分（SOA），实现微服务之间的隔离，避免相互影响，实现不同核心服务相互独立的容量评估和紧急情况下的限流熔断。<br>在活动进行过程中，如果业务流量过大，业务需要紧急扩容，底层容器服务需要能够支持分钟内的快速弹性扩容，因此容器调度、镜像分发、服务发现的效率都需要相应的进行提升和优化。<br>在处理业务弹性扩容的过程中，还有一点也需要考虑到，即数据库的连接数风险，在没有类似 dbproxy（数据库代理中间件）这样的服务进行连接池收敛的情况下，业务的弹性扩容能力需要考虑数据库的对连接数的承载力。</p>
<ul>
<li><strong>缓存层：数据读取加速</strong></li>
</ul>
<p>在抢购业务中，对商品库存数量的更改主要通过数据库进行，但是由于读取流量过大，一般需要通过两级缓存的机制进行优化，即：Java 服务进程内本地缓存–&gt;分布式缓存服务–&gt;数据库服务。<br>由于库存数据更新非常频繁，再加上后面要提到的库存拆分设计，缓存一致性在系统设计时是需要折中考虑的，库存数据的缓存往往被设计为延后定时刷新，而不是在每次成功扣减库存后去刷新，用户可能会看到商品仍有剩余库存，但是实际下单时返回售罄；更进一步甚至可以像 12306 那样只缓存“有余票”或“没有余票”两个状态。</p>
<ul>
<li><strong>数据层：数据库并发扣减库存</strong></li>
</ul>
<p>先简单介绍扣减库存在数据库上操作的例子，SQL 可以抽象为这种形式：“update stock_table set inventory&#x3D;inventory-1 where item_id&#x3D;xxxx and inventory&gt;0;” 即指定商品 ID（item_id），并判断库存充足情况下，扣减库存，隔离级别大于等于 ReadCommitted 的关系数据库可以保证这条语句执行的原子性。在处理对少量热点商品高并发扣减库存的业务时，关系数据库都会面临如下几个难题：</p>
<ol>
<li><p><strong>并发冲突代价</strong>：当前主流的关系数据库，无论是老牌商业产品 Oracle、流行开源项目 MySQL、还是国产开源新秀 TiDB，它们都使用经典的 WAL（write ahead log）方式来实现数据的持久化，即在事务提交时保证被更新的数据（WAL）写到硬盘后，才能给客户端返回成功。而硬盘写入的 latency 比内存操作大几个数量级，为了优化性能，大家都引入了组提交机制（group commit），即将同时提交的多个事务的数据，合并为一条 WAL 写入硬盘，对于每个事务来说，latency 还是一次硬盘写入 IO 的耗时，但是对于整个系统来说，可以将 TPS 从原来与硬盘 IOPS 相近的水平，提升几倍甚至几十倍。<br>但是并不是所有的并发事务都能够合并成组提交，如果两个事务之间存在冲突（比如并发修改同一行），那么无论是基于悲观锁进行并发控制的 Oracle&#x2F;MySQL，还是基于乐观锁进行并发控制的 TiDB，对于相互冲突的事务，他们本质上的处理方式，都只能是排队执行，即后一个事务要等前一个事务提交完成后才能执行。使用扣减库存的 SQL 举例如下：<br>找到并对商品记录加锁 –&gt; 判断库存余额 –&gt; 修改库存余额 –&gt; 提交 WAL 写盘 –&gt; 释放锁<br>针对同一个热点商品的多个并发事务，在上面加锁和释放锁之间的这段操作是无法做到并发执行的，因此在不引入任何优化的情况下，在同一个数据表中针对一个热点商品扣减库存 TPS 的天花板就是硬盘的 IOPS，而在大量并发事务都在争抢行锁的情况下，情况会进一步恶化，较高的系统负载，叠加上锁冲突检测等额外代价，可能造成系统的整体吞吐降低至个位数。</p>
</li>
<li><p><strong>可能存在超卖风险</strong>：考虑到上述并发事务提交 WAL 的问题，在实际系统上，为了降低写 WAL 的 latency，保证系统吞吐，一般会将写硬盘和同步备机调整为异步方式，而这个调整又会带来新的问题，即主库宕机情况下的数据不一致，主库重启或者备库切换为主库后，可能存在宕机前部分 WAL 没有被持久化的风险，反映到扣减库存的逻辑上就是已经被扣减的库存又被恢复了回来，最终在业务上形成超卖。2012 年阿里双 11 由于商品超卖给商家的赔付，产生了较大的经济损失。</p>
</li>
<li><p><strong>复杂事务恶化冲突</strong>：上面所举的例子是单行事务的 update，行锁的临界区（“找到并对商品记录加锁 –&gt; 判断库存余额 –&gt; 修改库存余额 –&gt; 提交 WAL 写盘 –&gt; 释放锁”）都在数据库处理的边界之内，但是在某些复杂场景下，在库存扣减的事务中可能存在多条语句的情况，比如扣减库存（update）+生成订单（insert）在一个事务内完成，这种情况下行锁的临界区扩大到受业务网络交互的影响，整体冲突加剧、吞吐进一步降低。</p>
</li>
</ol>
<p>数据库层面对于并发扣减库存的优化思路：</p>
<ol>
<li><p><strong>库存拆分</strong>：在业务层将同一个商品的库存记录拆分为多行甚至多个表里面去，降低在同一行或同一个数据表上的并发冲突，比如针对业务请求中的 userid 计算 hash 取模后确定要扣减哪个库存记录。这个方案能够很大程度的降低并发冲突，不需要数据库内核配合做修改，是行业内的主流方案，它的问题是：同一个商品不同库存记录的扣减速度不均衡（热点商品往往在几十秒内被强光，这个不均衡问题并不严重），给总库余额计数带来的复杂度，业务需要预先感知热点商品并且针对性的进行库存拆分。</p>
</li>
<li><p><strong>批处理</strong>：通过修改数据库内核代码，将相互冲突的事务，合并为一个事务或者一次 WAL 组提交，达到批处理的效果，AliSQL 的做法是在 MySQL server 层识别这类 update 语句，将它们解析后合并成为一条 SQL 再执行，比如 10 个扣减库存语句，合并为一个扣减库存的语句一次性扣减数量为 10，这个做法的优势是对数据库内核代码修改不多、复杂度可控，局限是只能在特定语句的基础上进行优化，没有比较好的普适性；OceanBase 则选择了另外一个优化思路，即提前释放锁，在事务确定要提交（比如单行事务执行成功或者用户在事务最后一条语句上标记“Commit on success”）的情况下，不需要等 WAL 同步，而先把事务涉及的行锁先释放掉，这样可以使得其他并发事务能够进入临界区，最终效果可以达到对同一行修改的多个并发事务的 WAL，可能在一次组提交内完成。</p>
</li>
<li><p><strong>请求排队</strong>：即使我们在数据库内核层面引入了上述“批处理”的优化，对热点行的并发扣减库存业务仍然会面临多个事务并发争抢进入临界区的情况，并发等锁的事务会占据宝贵的连接和线程资源，系统负载可能持续恶化；这里的一个优化思路是，在数据库内核层面将并发扣减同一个商品库存的事务排到一个队列处理（比如让用户在 SQL 注释上标记这个事务划分队列的依据，一般来说可以用商品 ID 取模），降低并发冲突，减少对连接和线程资源的占用，降低系统负载。这个优化目前已经在 AliSQL 上开源，效果还是比较明显的。</p>
</li>
<li><p><strong>存储过程或类似命令</strong>：对于一个事务里要执行多条语句的情况，会造成临界区的扩大，严重影响并发度，一个最有效的方案是数据库层面支持存储过程，多个语句放在存储过程里一次性提交给数据库；但是 MySQL 并不支持存储过程，因此可以针对具体场景引入一些类似存储过程的优化，当然核心仍然是将一个事务中的多条语句合并，实现与数据库在一次交互中完成。比如 AliSQL 的 Commit on success，可以用在扣减库存+生成订单的场景中，即开启事务后先执行几乎没有并发冲突的 insert 语句生成订单，然后带上 Commit on success 标记执行扣减库存命令，库存扣减成功后就立即提交事务，不需要等待客户端再发 commit，这样一来热点行冲突的临界区仍然与单行事务一样了。再比如 OceanBase 引入的… when row_affected()语法，允许在一个语句内先执行 update，然后根据受影响的函数来决定事务执行其他修改，这已经很像存储过程了。</p>
</li>
</ol>
<ul>
<li><strong>业务架构：减库存与生成订单一致性</strong></li>
</ul>
<p>在上面的例子中，扣减库存与生成订单的事务是在同一个数据库实例完成的，但是随着业务的拆分、业务逻辑的变化，扣减库存与生成订单可能被拆到不同的服务中去，那么如何保证扣减库存与生成订单的一致性，也成为一个有挑战的问题。<br>需要注意的是这种场景下，产生的数据不一致，不会造成商品超卖，而是会造成用户下单成功，却看不到待支付订单。4.20 我们在台州发放政府券的活动中，有约 30%的券没有及时发放到用户钱包中，本质上就是这样问题，当时的直接原因是扣减库存的金融业务撑住了压力，但是券系统超时触发了熔断，很多券没有成功发给用户，造成大量客诉，事后也花费了几个小时来使用 hive 上的日志数据进行补偿。<br>针对这类问题，一般通过 DRC&#x2F;DTS 这类中间件来配合实现数据一致性，即扣减库存成功后，MySQL 就会有相应的 binlog，DRC&#x2F;DTS 订阅库存中心的 binlog，订单中心再根据 DRC&#x2F;DTS 订阅的数据来生成订单。因为 MySQL binlog 有多份副本不会丢失，所以即使订单中心出现超时抖动等问题，在恢复正常后，就能够继续生成订单。当然，引入这类优化后，也意味着系统要进行异步化改造，因为生成订单的逻辑本质上变成了异步操作。</p>
<ul>
<li><strong>技术保障</strong><ul>
<li><strong>业务全链路压测</strong></li>
</ul>
</li>
</ul>
<p>全链路压测是阿里 2013 年在双 11 压力之下被逼出来的技能，由于线上线下环境多少都会有些不同，很多问题只有在实际生产环境才能暴露，对于秒杀类业务，线上压测也能够实际评估出系统的真实承载力，为容量预估给出重要参考。<br>同时阿里的全链路压测是真正的“全链路”，淘宝、天猫、支付宝的系统都会一同参与。</p>
<ul>
<li><strong>准实时监控</strong></li>
</ul>
<p>这里的技术挑战主要是在海量业务和数据库的场景下，如何做到全局有效而实时的监控数据采集和分析，一方面是为了实时监控系统健康度，另一方面则是 pr 需求。比如阿里张瑞说的：<br>“在零点前有一个倒计时环节，连线杭州光明顶作战指挥室，逍遥子会为大家揭幕 2015 双 11 启动，然后直接切换到我们的媒体大屏，所以对 GMV 数字的要求基本上是零延迟，这个挑战有多大不言而喻。”</p>
<ul>
<li><strong>实时热点发现</strong></li>
</ul>
<p>与准实时的监控类似，技术团队需要及时发现系统中的热点和瓶颈，并作出调整。实时热点的发现，需要业务层监控、数据库层监控一起配合改进优化，才能准确分析出热点。</p>
<ul>
<li><strong>容灾与高可用</strong></li>
</ul>
<p>业务容器宕机、数据库主库宕机、机房级宕机都可能出现，技术团队需要通过有效的容灾规划、set 化、分库分表等，降低“爆炸半径”，并且要做到快速切换。<br>因此这里的技术挑战是容器的快速扩容，容器镜像快速分发，数据库分库分表尽量降低单个集群主备切换的影响，业务层面的 set 化和灵活的流量切换。</p>
<ul>
<li><strong>系统预热</strong></li>
</ul>
<p>大量流量会在大促开始的第 0 秒集中涌入，活动开始前需要完成 JVM 预加载代码、缓存预热、数据库连接池预热等系统预热工作。<br>同时在各个系统的设计时也要做到避免对单点的依赖，原则仍然是降低“爆照半径”，防止大量流量进入后，把系统中的某个单点压垮，比如 2016 年美团 Tair 的故障，configserver 被自己的客户端压垮后造成整个系统的风暴。</p>
<p><a target="_blank" rel="noopener" href="https://km.sankuai.com/page/352913018">原文链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" data-id="cl3zp2b6m00261w7s5m3bby49" data-title="秒杀系统设计" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/索引" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T06:56:10.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/%E7%B4%A2%E5%BC%95/">索引</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.nlark.com/yuque/0/2022/png/1982501/1652357522468-ba1d526d-3e72-4cf7-b025-4b0b1e820739.png#clientId=u56022de0-5973-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=885&id=u2f6509f4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1992&originWidth=3611&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1453122&status=done&style=none&taskId=u5d285a79-4ea9-472b-a49e-88a63d33c9e&title=&width=1604.888888888889" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1982501/1652352096277-d1314bdd-c79b-4434-9d44-3b7f7594bb66.png#clientId=u0d5c38f2-9e8d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=398&id=u43e152e0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=895&originWidth=3053&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=252272&status=done&style=none&taskId=u70178c87-1d26-4cd3-8ae1-93696ff3897&title=&width=1356.888888888889" alt="image.png"></p>
<h4 id="InnoDB-树的高度计算"><a href="#InnoDB-树的高度计算" class="headerlink" title="InnoDB 树的高度计算"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/544e97672deb">InnoDB 树的高度计算</a></h4><blockquote>
<p>1）假设如下：<br>数据记录大小<code>1KB</code> -&gt; <code>叶子节点(页)可以存 16/1 = 16条数据</code><br>关键字和指针<code>bigint 8B + 页指针6B</code> -&gt; <code>非叶子节点可以存 16384/14 = 1170个对象(关键字-页指针)</code><br>2）高度为 2 和 3 的 B+树<br>高度为 2 的 B+树：<code>1170 * 16 = 18720，约存2w条数据记录。</code><br>高度为 3 的 B+树：<code>1170 * 1170 * 16 = 21902400，约存2千万条数据记录。</code><br>所以：<code>InnoDB中B+树的高度一般为1~3层。mysql查找一页时代表依次IO，通过主键索引只需要1~3次IO。</code><br>3）InnoDB 表空间 ibd 文件中，<code>约定page_no为3的，代表主索引的root page.</code></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/%E7%B4%A2%E5%BC%95/" data-id="cl3zp2b6p002d1w7scy0g2kse" data-title="索引" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/Eureka" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/Eureka/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T06:54:35.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/Eureka/">Eureka</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1982501/1600226191956-42827164-d19a-40bb-9fc7-decdda976254.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=360&originWidth=648&size=60755&status=done&style=none&width=648" alt="image.png"></p>
<h1 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h1><h3 id="三级缓存结构"><a href="#三级缓存结构" class="headerlink" title="三级缓存结构"></a>三级缓存结构</h3><table>
<thead>
<tr>
<th>缓存（类的成员变量）</th>
<th>变量类型</th>
<th>类名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>registry</strong></td>
<td>ConcurrentHashMap</td>
<td>AbstractInstanceRegistry</td>
<td>实时更新</td>
</tr>
<tr>
<td><strong>readWriteCacheMap</strong></td>
<td>Guava Cache&#x2F;LoadingCache</td>
<td>ResponseCacheImpl</td>
<td>实时更新</td>
</tr>
<tr>
<td><strong>readOnlyCacheMap</strong></td>
<td>ConcurrentHashMap</td>
<td>ResponseCacheImpl</td>
<td>周期更新</td>
</tr>
</tbody></table>
<p>三级缓存尽可能保证了内存注册表数据 registry 不会出现频繁的读写冲突问题<br>但同时也会使得服务注册信息有一定的时间延迟，但对于<strong>读多写少</strong>的场景下，这种结构是十分合适的</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol>
<li><strong>当服务变更时（服务注册&#x2F;下线），直接变更 registry，然后使 readWriteCacheMap 失效，30s 后当查询到 readWriteCacheMap 已经失效后，使 readOnlyCacheMap 失效，有服务信息读取时，会以 readOnlyCacheMap-&gt;readWriteCacheMap-&gt;registry 的顺序查询未失效的数据，并依次填充已经失效的数据</strong></li>
<li><strong>readOnlyCacheMap</strong>默认每隔 30s 从<strong>readWriteCacheMap 更新</strong></li>
<li>EurekaClient 默认从<strong>readOnlyCacheMap</strong>更新，可以设置为从<strong>readWriteCacheMap 直接更新，小规模系统直接从 readWriteCacheMap 更高效</strong></li>
<li>EurekaServer 集群间从<strong>registry 同步数据</strong></li>
</ol>
<h1 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h1><p>二级缓存结构</p>
<table>
<thead>
<tr>
<th>缓存（类的成员变量）</th>
<th>变量类型</th>
<th>类名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>localRegionApps</td>
<td>AtomicReference</td>
<td>DiscoveryClient</td>
<td><strong>周期更新</strong></td>
</tr>
<tr>
<td>upServerListZoneMap</td>
<td>ConcurrentHashMap</td>
<td>LoadBalancerStats</td>
<td><strong>周期更新</strong></td>
</tr>
</tbody></table>
<ol>
<li>localRegionApps 为 EurekaClient 保存服务注册信息，启动后立即向 Server 全量更新，默认每 30s 增量更新</li>
<li>upServerListZoneMap 为 Ribbon 保存使用且状态为 UP 的服务注册信息，启动后延时 1s 向 Client 更新，默认每 30s 更新</li>
</ol>
<h1 id="感知延迟时间计算"><a href="#感知延迟时间计算" class="headerlink" title="感知延迟时间计算"></a>感知延迟时间计算</h1><h3 id="正常上线和下线"><a href="#正常上线和下线" class="headerlink" title="正常上线和下线"></a>正常上线和下线</h3><p>readWrite -&gt; readOnly -&gt; Client -&gt; Ribbon 各 30s<br>30(readOnly)+30(Client)+30(Ribbon)&#x3D;90s</p>
<h3 id="非正常的上下线"><a href="#非正常的上下线" class="headerlink" title="非正常的上下线"></a>非正常的上下线</h3><p>90s(正常延时)+180s(注册中心服务剔除机制)&#x3D;270s</p>
<h1 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h1><h3 id="EurekaServer"><a href="#EurekaServer" class="headerlink" title="EurekaServer"></a>EurekaServer</h3><ol>
<li>缩短 readOnlyCacheMap 到<strong>readWriteCacheMap 的同步周期时间</strong></li>
<li>小规模系统可以设置为直接从<strong>readWriteCacheMap 同步服务信息</strong></li>
</ol>
<h3 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h3><ol>
<li>服务通过接口正常下线或者 kill&#x2F;kill -15 下线，不要通过 kill -9 下线服务</li>
<li>缩短 EurekaClient 缓存的同步周期时间</li>
<li>服务提供者延迟下线，先通过接口修改 EurekaServer 中服务的状态为 Down，90s 后停止服务，可以做到几乎无延时</li>
<li>修改心跳频率有可能会使 Eureka 自我保护模式失效</li>
</ol>
<h3 id="优化经验"><a href="#优化经验" class="headerlink" title="优化经验"></a>优化经验</h3><p>一个上百个服务，几千台机器的系统，按照 30s 频率请求 Eureka Server，日请求量在千万级，每秒的访问量在 150 次左右<br>由于 Eureka 基于内存，一个 Eureka 实例每秒应付几百的并发没有问题</p>
<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/y_1BCrbLONU61s1gbGsU">详解 Eureka 缓存机制-infoQ</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/u/3747772?tab=newest&catalogId=5773053">Eureka 四篇文章解析-oschina</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/Eureka/" data-id="cl3zp2b5o000d1w7s8znf8vi8" data-title="Eureka" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-yuque/Hystrix" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/20/yuque/Hystrix/" class="article-date">
  <time class="dt-published" datetime="2020-08-20T06:54:12.000Z" itemprop="datePublished">2020-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/20/yuque/Hystrix/">Hystrix</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1982501/1608028542595-c04af846-3aac-4d85-a055-62165f58498a.jpeg#align=left&display=inline&height=667&margin=%5Bobject%20Object%5D&originHeight=667&originWidth=1372&size=0&status=done&style=none&width=1372"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1982501/1608032099184-93a22fba-5173-44c2-b144-193b4edde7ba.png#align=left&display=inline&height=525&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1050&originWidth=3011&size=354214&status=done&style=none&width=1505.5" alt="image.png"></p>
<h2 id="命令执行模式"><a href="#命令执行模式" class="headerlink" title="命令执行模式"></a>命令执行模式</h2><p>有四种方法来执行命令（前面两种只对 HystrixCommand 有用，HystrixObservableCommand 没有相应的方法）。</p>
<ul>
<li>execute－阻塞，阻塞直到收到调用的返回值（或者抛出异常）</li>
<li>queue 返回一个 future，可以通过 future 来获取调用的返回值。</li>
<li>observe 监听一个调用返回的 Observable 对象。</li>
<li>toObservable 返回一个 Observable，当监听该 Observable 后 hystrix 命令将会执行并返回结果。</li>
</ul>
<h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><ol>
<li>请求量到达了指定值</li>
<li>异常比率超过了指定值</li>
<li>在经过指定窗口期后，状态将会被设置为 HALF-OPEN，如果该请求失败了，状态重新被设置为 OPEN 并且等待下一个窗口期，如果请求成功了，状态设置为 CLOSE。</li>
</ol>
<h2 id="调用执行模式"><a href="#调用执行模式" class="headerlink" title="调用执行模式"></a>调用执行模式</h2><ol>
<li>线程池模式<ol>
<li>每个服务分配一个线程池</li>
<li>适用于请求并发量大，并且耗时长</li>
</ol>
</li>
<li>信号量模式<ol>
<li>设定每个服务的信号量上限</li>
<li>适用于请求并发量大，并且耗时短</li>
</ol>
</li>
</ol>
<hr>
<table>
<thead>
<tr>
<th></th>
<th>线程池</th>
<th>信号量</th>
</tr>
</thead>
<tbody><tr>
<td>线程</td>
<td>请求线程和调用 provider 线程不是同一条线程</td>
<td>请求线程和调用 provider 线程是同一条线程</td>
</tr>
<tr>
<td>开销</td>
<td>排队、调度、上下文切换等</td>
<td>无线程切换，开销低</td>
</tr>
<tr>
<td>异步</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>并发支持</td>
<td>支持：最大线程池大小</td>
<td>支持：最大信号量上限</td>
</tr>
<tr>
<td>传递 Header</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>支持超时</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h2 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h2><h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><p>延长单个请求时间，减少请求时建立出的线程数。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://handsomebo.com/2020/08/20/yuque/Hystrix/" data-id="cl3zp2b5p000g1w7s3khlh8sh" data-title="Hystrix" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%80%E5%8E%86/" rel="tag">简历</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/%E7%AE%80%E5%8E%86/" style="font-size: 10px;">简历</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/01/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86-%E5%BE%90%E5%8D%9A/">个人简历</a>
          </li>
        
          <li>
            <a href="/2022/06/01/yuque/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/">系统设计相关</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%A1%88/">问题以及方案</a>
          </li>
        
          <li>
            <a href="/2022/05/15/yuque/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/">缓存和数据库双写不一致</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>